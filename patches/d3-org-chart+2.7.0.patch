diff --git a/node_modules/d3-org-chart/build/d3-org-chart.js b/node_modules/d3-org-chart/build/d3-org-chart.js
index 8e0cf44..121b99d 100644
--- a/node_modules/d3-org-chart/build/d3-org-chart.js
+++ b/node_modules/d3-org-chart/build/d3-org-chart.js
@@ -23,6 +23,7 @@
         constructor() {
 
             // Exposed variables  test test
+            console.log('build')
             const attrs = {
 
                 /* NOT INTENDED FOR PUBLIC OVERRIDE */
@@ -519,6 +520,7 @@
             //InnerFunctions which will update visuals
             const attrs = this.getChartState();
             if (!attrs.data || attrs.data.length == 0) {
+                console.log('pleaseee')
                 console.log('ORG CHART - Data is empty')
                 return this;
             }
@@ -1254,6 +1256,7 @@
 
         // Toggle children on click.
         onButtonClick(event, d) {
+            console.log("yeeeeeeeeeeeeees")
             const attrs = this.getChartState();
             if (d.data._pagingButton) {
                 return;
diff --git a/node_modules/d3-org-chart/build/d3-org-chart.min.js b/node_modules/d3-org-chart/build/d3-org-chart.min.js
deleted file mode 100644
index 481d9a4..0000000
--- a/node_modules/d3-org-chart/build/d3-org-chart.min.js
+++ /dev/null
@@ -1,69 +0,0 @@
-!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("d3-selection"),require("d3-array"),require("d3-hierarchy"),require("d3-zoom"),require("d3-flextree"),require("d3-shape")):"function"==typeof define&&define.amd?define(["exports","d3-selection","d3-array","d3-hierarchy","d3-zoom","d3-flextree","d3-shape"],e):e(t.d3=t.d3||{},t.d3,t.d3,t.d3,t.d3,t.d3,t.d3)}(this,function(t,e,a,n,i,r,o){"use strict";const u={selection:e.selection,select:e.select,max:a.max,min:a.min,sum:a.sum,cumsum:a.cumsum,tree:n.tree,stratify:n.stratify,zoom:i.zoom,zoomIdentity:i.zoomIdentity,linkHorizontal:o.linkHorizontal,flextree:r.flextree};t.OrgChart=class{constructor(){const a={id:"ID"+Math.floor(1e6*Math.random()),firstDraw:!0,ctx:document.createElement("canvas").getContext("2d"),expandLevel:1,nodeDefaultBackground:"none",lastTransform:{x:0,y:0,k:1},allowedNodesCount:{},zoomBehavior:null,svgWidth:800,svgHeight:window.innerHeight-100,container:"body",data:null,connections:[],defaultFont:"Helvetica",nodeId:t=>t.nodeId||t.id,parentNodeId:t=>t.parentNodeId||t.parentId,rootMargin:40,nodeWidth:t=>250,nodeHeight:t=>150,neighbourMargin:(t,e)=>80,siblingsMargin:t=>20,childrenMargin:t=>60,compactMarginPair:t=>100,compactMarginBetween:t=>20,nodeButtonWidth:t=>40,nodeButtonHeight:t=>40,nodeButtonX:t=>-20,nodeButtonY:t=>-20,linkYOffset:30,pagingStep:t=>5,minPagingVisibleNodes:t=>2e3,scaleExtent:[.001,20],duration:400,imageName:"Chart",setActiveNodeCentered:!0,layout:"top",compact:!0,onZoomStart:t=>{},onZoom:t=>{},onZoomEnd:t=>{},onNodeClick:t=>t,nodeContent:t=>`<div style="padding:5px;font-size:10px;">Sample Node(id=${t.id}), override using <br/> 
-            <code>chart.nodeContent({data}=>{ <br/>
-             &nbsp;&nbsp;&nbsp;&nbsp;return '' // Custom HTML <br/>
-             })</code>
-             <br/> 
-             Or check different <a href="https://github.com/bumbeishvili/org-chart#jump-to-examples" target="_blank">layout examples</a>
-             </div>`,buttonContent:({node:e,state:t})=>{return`<div style="border:1px solid #E4E2E9;border-radius:3px;padding:3px;font-size:9px;margin:auto auto;background-color:white"> ${{left:t=>t?`<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
-                      <path d="M14.283 3.50094L6.51 11.4749C6.37348 11.615 6.29707 11.8029 6.29707 11.9984C6.29707 12.194 6.37348 12.3819 6.51 12.5219L14.283 20.4989C14.3466 20.5643 14.4226 20.6162 14.5066 20.6516C14.5906 20.6871 14.6808 20.7053 14.772 20.7053C14.8632 20.7053 14.9534 20.6871 15.0374 20.6516C15.1214 20.6162 15.1974 20.5643 15.261 20.4989C15.3918 20.365 15.4651 20.1852 15.4651 19.9979C15.4651 19.8107 15.3918 19.6309 15.261 19.4969L7.9515 11.9984L15.261 4.50144C15.3914 4.36756 15.4643 4.18807 15.4643 4.00119C15.4643 3.81431 15.3914 3.63482 15.261 3.50094C15.1974 3.43563 15.1214 3.38371 15.0374 3.34827C14.9534 3.31282 14.8632 3.29456 14.772 3.29456C14.6808 3.29456 14.5906 3.31282 14.5066 3.34827C14.4226 3.38371 14.3466 3.43563 14.283 3.50094V3.50094Z" fill="#716E7B" stroke="#716E7B"/>
-                      </svg></span><span style="color:#716E7B">${e.data._directSubordinatesPaging} </span></div>`:`<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
-                          <path d="M7.989 3.49944C7.85817 3.63339 7.78492 3.8132 7.78492 4.00044C7.78492 4.18768 7.85817 4.36749 7.989 4.50144L15.2985 11.9999L7.989 19.4969C7.85817 19.6309 7.78492 19.8107 7.78492 19.9979C7.78492 20.1852 7.85817 20.365 7.989 20.4989C8.05259 20.5643 8.12863 20.6162 8.21261 20.6516C8.2966 20.6871 8.38684 20.7053 8.478 20.7053C8.56916 20.7053 8.6594 20.6871 8.74338 20.6516C8.82737 20.6162 8.90341 20.5643 8.967 20.4989L16.74 12.5234C16.8765 12.3834 16.9529 12.1955 16.9529 11.9999C16.9529 11.8044 16.8765 11.6165 16.74 11.4764L8.967 3.50094C8.90341 3.43563 8.82737 3.38371 8.74338 3.34827C8.6594 3.31282 8.56916 3.29456 8.478 3.29456C8.38684 3.29456 8.2966 3.31282 8.21261 3.34827C8.12863 3.38371 8.05259 3.43563 7.989 3.50094V3.49944Z" fill="#716E7B" stroke="#716E7B"/>
-                          </svg></span><span style="color:#716E7B">${e.data._directSubordinatesPaging} </span></div>`,bottom:t=>t?`<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
-                       <path d="M19.497 7.98903L12 15.297L4.503 7.98903C4.36905 7.85819 4.18924 7.78495 4.002 7.78495C3.81476 7.78495 3.63495 7.85819 3.501 7.98903C3.43614 8.05257 3.38462 8.12842 3.34944 8.21213C3.31427 8.29584 3.29615 8.38573 3.29615 8.47653C3.29615 8.56733 3.31427 8.65721 3.34944 8.74092C3.38462 8.82463 3.43614 8.90048 3.501 8.96403L11.4765 16.74C11.6166 16.8765 11.8044 16.953 12 16.953C12.1956 16.953 12.3834 16.8765 12.5235 16.74L20.499 8.96553C20.5643 8.90193 20.6162 8.8259 20.6517 8.74191C20.6871 8.65792 20.7054 8.56769 20.7054 8.47653C20.7054 8.38537 20.6871 8.29513 20.6517 8.21114C20.6162 8.12715 20.5643 8.05112 20.499 7.98753C20.3651 7.85669 20.1852 7.78345 19.998 7.78345C19.8108 7.78345 19.6309 7.85669 19.497 7.98753V7.98903Z" fill="#716E7B" stroke="#716E7B"/>
-                       </svg></span><span style="margin-left:1px;color:#716E7B" >${e.data._directSubordinatesPaging} </span></div>
-                       `:`<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
-                       <path d="M11.457 8.07005L3.49199 16.4296C3.35903 16.569 3.28485 16.7543 3.28485 16.9471C3.28485 17.1398 3.35903 17.3251 3.49199 17.4646L3.50099 17.4736C3.56545 17.5414 3.64304 17.5954 3.72904 17.6324C3.81504 17.6693 3.90765 17.6883 4.00124 17.6883C4.09483 17.6883 4.18745 17.6693 4.27344 17.6324C4.35944 17.5954 4.43703 17.5414 4.50149 17.4736L12.0015 9.60155L19.4985 17.4736C19.563 17.5414 19.6405 17.5954 19.7265 17.6324C19.8125 17.6693 19.9052 17.6883 19.9987 17.6883C20.0923 17.6883 20.1849 17.6693 20.2709 17.6324C20.3569 17.5954 20.4345 17.5414 20.499 17.4736L20.508 17.4646C20.641 17.3251 20.7151 17.1398 20.7151 16.9471C20.7151 16.7543 20.641 16.569 20.508 16.4296L12.543 8.07005C12.4729 7.99653 12.3887 7.93801 12.2954 7.89801C12.202 7.85802 12.1015 7.8374 12 7.8374C11.8984 7.8374 11.798 7.85802 11.7046 7.89801C11.6113 7.93801 11.527 7.99653 11.457 8.07005Z" fill="#716E7B" stroke="#716E7B"/>
-                       </svg></span><span style="margin-left:1px;color:#716E7B" >${e.data._directSubordinatesPaging} </span></div>
-                    `,right:t=>t?`<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
-                       <path d="M7.989 3.49944C7.85817 3.63339 7.78492 3.8132 7.78492 4.00044C7.78492 4.18768 7.85817 4.36749 7.989 4.50144L15.2985 11.9999L7.989 19.4969C7.85817 19.6309 7.78492 19.8107 7.78492 19.9979C7.78492 20.1852 7.85817 20.365 7.989 20.4989C8.05259 20.5643 8.12863 20.6162 8.21261 20.6516C8.2966 20.6871 8.38684 20.7053 8.478 20.7053C8.56916 20.7053 8.6594 20.6871 8.74338 20.6516C8.82737 20.6162 8.90341 20.5643 8.967 20.4989L16.74 12.5234C16.8765 12.3834 16.9529 12.1955 16.9529 11.9999C16.9529 11.8044 16.8765 11.6165 16.74 11.4764L8.967 3.50094C8.90341 3.43563 8.82737 3.38371 8.74338 3.34827C8.6594 3.31282 8.56916 3.29456 8.478 3.29456C8.38684 3.29456 8.2966 3.31282 8.21261 3.34827C8.12863 3.38371 8.05259 3.43563 7.989 3.50094V3.49944Z" fill="#716E7B" stroke="#716E7B"/>
-                       </svg></span><span style="color:#716E7B">${e.data._directSubordinatesPaging} </span></div>`:`<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
-                       <path d="M14.283 3.50094L6.51 11.4749C6.37348 11.615 6.29707 11.8029 6.29707 11.9984C6.29707 12.194 6.37348 12.3819 6.51 12.5219L14.283 20.4989C14.3466 20.5643 14.4226 20.6162 14.5066 20.6516C14.5906 20.6871 14.6808 20.7053 14.772 20.7053C14.8632 20.7053 14.9534 20.6871 15.0374 20.6516C15.1214 20.6162 15.1974 20.5643 15.261 20.4989C15.3918 20.365 15.4651 20.1852 15.4651 19.9979C15.4651 19.8107 15.3918 19.6309 15.261 19.4969L7.9515 11.9984L15.261 4.50144C15.3914 4.36756 15.4643 4.18807 15.4643 4.00119C15.4643 3.81431 15.3914 3.63482 15.261 3.50094C15.1974 3.43563 15.1214 3.38371 15.0374 3.34827C14.9534 3.31282 14.8632 3.29456 14.772 3.29456C14.6808 3.29456 14.5906 3.31282 14.5066 3.34827C14.4226 3.38371 14.3466 3.43563 14.283 3.50094V3.50094Z" fill="#716E7B" stroke="#716E7B"/>
-                       </svg></span><span style="color:#716E7B">${e.data._directSubordinatesPaging} </span></div>`,top:t=>t?`<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
-                        <path d="M11.457 8.07005L3.49199 16.4296C3.35903 16.569 3.28485 16.7543 3.28485 16.9471C3.28485 17.1398 3.35903 17.3251 3.49199 17.4646L3.50099 17.4736C3.56545 17.5414 3.64304 17.5954 3.72904 17.6324C3.81504 17.6693 3.90765 17.6883 4.00124 17.6883C4.09483 17.6883 4.18745 17.6693 4.27344 17.6324C4.35944 17.5954 4.43703 17.5414 4.50149 17.4736L12.0015 9.60155L19.4985 17.4736C19.563 17.5414 19.6405 17.5954 19.7265 17.6324C19.8125 17.6693 19.9052 17.6883 19.9987 17.6883C20.0923 17.6883 20.1849 17.6693 20.2709 17.6324C20.3569 17.5954 20.4345 17.5414 20.499 17.4736L20.508 17.4646C20.641 17.3251 20.7151 17.1398 20.7151 16.9471C20.7151 16.7543 20.641 16.569 20.508 16.4296L12.543 8.07005C12.4729 7.99653 12.3887 7.93801 12.2954 7.89801C12.202 7.85802 12.1015 7.8374 12 7.8374C11.8984 7.8374 11.798 7.85802 11.7046 7.89801C11.6113 7.93801 11.527 7.99653 11.457 8.07005Z" fill="#716E7B" stroke="#716E7B"/>
-                        </svg></span><span style="margin-left:1px;color:#716E7B">${e.data._directSubordinatesPaging} </span></div>
-                        `:`<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
-                        <path d="M19.497 7.98903L12 15.297L4.503 7.98903C4.36905 7.85819 4.18924 7.78495 4.002 7.78495C3.81476 7.78495 3.63495 7.85819 3.501 7.98903C3.43614 8.05257 3.38462 8.12842 3.34944 8.21213C3.31427 8.29584 3.29615 8.38573 3.29615 8.47653C3.29615 8.56733 3.31427 8.65721 3.34944 8.74092C3.38462 8.82463 3.43614 8.90048 3.501 8.96403L11.4765 16.74C11.6166 16.8765 11.8044 16.953 12 16.953C12.1956 16.953 12.3834 16.8765 12.5235 16.74L20.499 8.96553C20.5643 8.90193 20.6162 8.8259 20.6517 8.74191C20.6871 8.65792 20.7054 8.56769 20.7054 8.47653C20.7054 8.38537 20.6871 8.29513 20.6517 8.21114C20.6162 8.12715 20.5643 8.05112 20.499 7.98753C20.3651 7.85669 20.1852 7.78345 19.998 7.78345C19.8108 7.78345 19.6309 7.85669 19.497 7.98753V7.98903Z" fill="#716E7B" stroke="#716E7B"/>
-                        </svg></span><span style="margin-left:1px;color:#716E7B">${e.data._directSubordinatesPaging} </span></div>
-                    `}[t.layout](e.children)}  </div>`},pagingButton:(t,e,a,n)=>{var n=n.pagingStep(t.parent),i=t.parent.data._pagingStep,t=t.parent.data._directSubordinatesPaging-i;return`
-                   <div style="margin-top:90px;">
-                      <div style="display:flex;width:170px;border-radius:20px;padding:5px 15px; padding-bottom:4px;;background-color:#E5E9F2">
-                      <div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
-                      <path d="M5.59 7.41L10.18 12L5.59 16.59L7 18L13 12L7 6L5.59 7.41ZM16 6H18V18H16V6Z" fill="#716E7B" stroke="#716E7B"/>
-                      </svg>
-                      </div><div style="line-height:2"> Show next ${Math.min(t,n)}  nodes </div></div>
-                   </div>
-                `},nodeUpdate:function(t,e,a){u.select(this).select(".node-rect").attr("stroke",t=>t.data._highlighted||t.data._upToTheRootHighlighted?"#E27396":"none").attr("stroke-width",t.data._highlighted||t.data._upToTheRootHighlighted?10:1)},linkUpdate:function(t,e,a){u.select(this).attr("stroke",t=>t.data._upToTheRootHighlighted?"#E27396":"#E4E2E9").attr("stroke-width",t=>t.data._upToTheRootHighlighted?5:1),t.data._upToTheRootHighlighted&&u.select(this).raise()},hdiagonal:function(t,e,a){var n=t.x,t=t.y,i=e.x,e=e.y,o=a&&a.x||n,a=a&&a.y||t,r=i-n<0?-1:1,d=e-t<0?-1:1,s=Math.abs(i-n)/2<35?Math.abs(i-n)/2:35,s=Math.abs(e-t)/2<s?Math.abs(e-t)/2:s,l=(Math.abs(e-t),Math.abs(i-n)/2-s);return`
-                          M ${o} ${a}
-                          L ${o} ${t}
-                          L ${n} ${t}
-                          L ${n+l*r} ${t}
-                          C ${n+l*r+s*r} ${t} 
-                            ${n+l*r+s*r} ${t} 
-                            ${n+l*r+s*r} ${t+s*d}
-                          L ${n+l*r+s*r} ${e-s*d} 
-                          C ${n+l*r+s*r}  ${e} 
-                            ${n+l*r+s*r}  ${e} 
-                            ${i-l*r}  ${e}
-                          L ${i} ${e}
-               `},diagonal:function(t,e,a,n={sy:0}){var i=t.x,t=t.y,o=e.x,e=e.y,r=a&&a.x||i,a=a&&a.y||t,d=o-i<0?-1:1,s=e-t<0?-1:1,n=(t+=n.sy,Math.abs(o-i)/2<35?Math.abs(o-i)/2:35),n=Math.abs(e-t)/2<n?Math.abs(e-t)/2:n,l=Math.abs(e-t)/2-n;return`
-                          M ${r} ${a}
-                          L ${i} ${a}
-                          L ${i} ${t}
-                          L ${i} ${t+l*s}
-                          C  ${i} ${t+l*s+n*s} ${i} ${t+l*s+n*s} ${i+n*d} ${t+l*s+n*s}
-                          L ${i+(Math.abs(o-i)-2*n)*d+n*d} ${t+l*s+n*s}
-                          C  ${o}  ${t+l*s+n*s} ${o}  ${t+l*s+n*s} ${o} ${e-l*s}
-                          L ${o} ${e}
-               `},defs:function(a,t){return`<defs>
-                    ${t.map(t=>{var e=this.getTextWidth(t.label,{ctx:a.ctx,fontSize:2,defaultFont:a.defaultFont});return`
-                       <marker id="${t.from+"_"+t.to}" refX="${t._source.x<t._target.x?-7:7}" refY="5" markerWidth="500"  markerHeight="500"  orient="${t._source.x<t._target.x?"auto":"auto-start-reverse"}" >
-                       <rect rx=0.5 width=${t.label?e+3:0} height=3 y=1  fill="#E27396"></rect>
-                       <text font-size="2px" x=1 fill="white" y=3>${t.label||""}</text>
-                       </marker>
-
-                       <marker id="arrow-${t.from+"_"+t.to}"  markerWidth="500"  markerHeight="500"  refY="2"  refX="1" orient="${t._source.x<t._target.x?"auto":"auto-start-reverse"}" >
-                       <path transform="translate(0)" d='M0,0 V4 L2,2 Z' fill='#E27396' />
-                       </marker>
-                    `}).join("")}
-                    </defs>
-                    `},connectionsUpdate:function(t,e,a){u.select(this).attr("stroke",t=>"#E27396").attr("stroke-linecap","round").attr("stroke-width",t=>"5").attr("pointer-events","none").attr("marker-start",t=>`url(#${t.from+"_"+t.to})`).attr("marker-end",t=>`url(#arrow-${t.from+"_"+t.to})`)},linkGroupArc:u.linkHorizontal().x(t=>t.x).y(t=>t.y),layoutBindings:{left:{nodeLeftX:t=>0,nodeRightX:t=>t.width,nodeTopY:t=>-t.height/2,nodeBottomY:t=>t.height/2,nodeJoinX:t=>t.x+t.width,nodeJoinY:t=>t.y-t.height/2,linkJoinX:t=>t.x+t.width,linkJoinY:t=>t.y,linkX:t=>t.x,linkY:t=>t.y,linkCompactXStart:t=>t.x+t.width/2,linkCompactYStart:t=>t.y+(t.compactEven?t.height/2:-t.height/2),compactLinkMidX:(t,e)=>t.firstCompactNode.x,compactLinkMidY:(t,e)=>t.firstCompactNode.y+t.firstCompactNode.flexCompactDim[0]/4+e.compactMarginPair(t)/4,linkParentX:t=>t.parent.x+t.parent.width,linkParentY:t=>t.parent.y,buttonX:t=>t.width,buttonY:t=>t.height/2,centerTransform:({rootMargin:t,centerY:e,scale:a})=>`translate(${t},${e}) scale(${a})`,compactDimension:{sizeColumn:t=>t.height,sizeRow:t=>t.width,reverse:t=>t.slice().reverse()},nodeFlexSize:({height:t,width:e,siblingsMargin:a,childrenMargin:n,state:i,node:o})=>{return i.compact&&o.flexCompactDim?[o.flexCompactDim[0],o.flexCompactDim[1]]:[t+a,e+n]},zoomTransform:({centerY:t,scale:e})=>`translate(0,${t}) scale(${e})`,diagonal:this.hdiagonal.bind(this),swap:t=>{var e=t.x;t.x=t.y,t.y=e},nodeUpdateTransform:({x:t,y:e,height:a})=>`translate(${t},${e-a/2})`},top:{nodeLeftX:t=>-t.width/2,nodeRightX:t=>t.width/2,nodeTopY:t=>0,nodeBottomY:t=>t.height,nodeJoinX:t=>t.x-t.width/2,nodeJoinY:t=>t.y+t.height,linkJoinX:t=>t.x,linkJoinY:t=>t.y+t.height,linkCompactXStart:t=>t.x+(t.compactEven?t.width/2:-t.width/2),linkCompactYStart:t=>t.y+t.height/2,compactLinkMidX:(t,e)=>t.firstCompactNode.x+t.firstCompactNode.flexCompactDim[0]/4+e.compactMarginPair(t)/4,compactLinkMidY:t=>t.firstCompactNode.y,compactDimension:{sizeColumn:t=>t.width,sizeRow:t=>t.height,reverse:t=>t},linkX:t=>t.x,linkY:t=>t.y,linkParentX:t=>t.parent.x,linkParentY:t=>t.parent.y+t.parent.height,buttonX:t=>t.width/2,buttonY:t=>t.height,centerTransform:({rootMargin:t,scale:e,centerX:a})=>`translate(${a},${t}) scale(${e})`,nodeFlexSize:({height:t,width:e,siblingsMargin:a,childrenMargin:n,state:i,node:o})=>{return i.compact&&o.flexCompactDim?[o.flexCompactDim[0],o.flexCompactDim[1]]:[e+a,t+n]},zoomTransform:({centerX:t,scale:e})=>`translate(${t},0}) scale(${e})`,diagonal:this.diagonal.bind(this),swap:t=>{},nodeUpdateTransform:({x:t,y:e,width:a})=>`translate(${t-a/2},${e})`},bottom:{nodeLeftX:t=>-t.width/2,nodeRightX:t=>t.width/2,nodeTopY:t=>-t.height,nodeBottomY:t=>0,nodeJoinX:t=>t.x-t.width/2,nodeJoinY:t=>t.y-t.height-t.height,linkJoinX:t=>t.x,linkJoinY:t=>t.y-t.height,linkCompactXStart:t=>t.x+(t.compactEven?t.width/2:-t.width/2),linkCompactYStart:t=>t.y-t.height/2,compactLinkMidX:(t,e)=>t.firstCompactNode.x+t.firstCompactNode.flexCompactDim[0]/4+e.compactMarginPair(t)/4,compactLinkMidY:t=>t.firstCompactNode.y,linkX:t=>t.x,linkY:t=>t.y,compactDimension:{sizeColumn:t=>t.width,sizeRow:t=>t.height,reverse:t=>t},linkParentX:t=>t.parent.x,linkParentY:t=>t.parent.y-t.parent.height,buttonX:t=>t.width/2,buttonY:t=>0,centerTransform:({rootMargin:t,scale:e,centerX:a,chartHeight:n})=>`translate(${a},${n-t}) scale(${e})`,nodeFlexSize:({height:t,width:e,siblingsMargin:a,childrenMargin:n,state:i,node:o})=>{return i.compact&&o.flexCompactDim?[o.flexCompactDim[0],o.flexCompactDim[1]]:[e+a,t+n]},zoomTransform:({centerX:t,scale:e})=>`translate(${t},0}) scale(${e})`,diagonal:this.diagonal.bind(this),swap:t=>{t.y=-t.y},nodeUpdateTransform:({x:t,y:e,width:a,height:n})=>`translate(${t-a/2},${e-n})`},right:{nodeLeftX:t=>-t.width,nodeRightX:t=>0,nodeTopY:t=>-t.height/2,nodeBottomY:t=>t.height/2,nodeJoinX:t=>t.x-t.width-t.width,nodeJoinY:t=>t.y-t.height/2,linkJoinX:t=>t.x-t.width,linkJoinY:t=>t.y,linkX:t=>t.x,linkY:t=>t.y,linkParentX:t=>t.parent.x-t.parent.width,linkParentY:t=>t.parent.y,buttonX:t=>0,buttonY:t=>t.height/2,linkCompactXStart:t=>t.x-t.width/2,linkCompactYStart:t=>t.y+(t.compactEven?t.height/2:-t.height/2),compactLinkMidX:(t,e)=>t.firstCompactNode.x,compactLinkMidY:(t,e)=>t.firstCompactNode.y+t.firstCompactNode.flexCompactDim[0]/4+e.compactMarginPair(t)/4,centerTransform:({rootMargin:t,centerY:e,scale:a,chartWidth:n})=>`translate(${n-t},${e}) scale(${a})`,nodeFlexSize:({height:t,width:e,siblingsMargin:a,childrenMargin:n,state:i,node:o})=>{return i.compact&&o.flexCompactDim?[o.flexCompactDim[0],o.flexCompactDim[1]]:[t+a,e+n]},compactDimension:{sizeColumn:t=>t.height,sizeRow:t=>t.width,reverse:t=>t.slice().reverse()},zoomTransform:({centerY:t,scale:e})=>`translate(0,${t}) scale(${e})`,diagonal:this.hdiagonal.bind(this),swap:t=>{var e=t.x;t.x=-t.y,t.y=e},nodeUpdateTransform:({x:t,y:e,width:a,height:n})=>`translate(${t-a},${e-n/2})`}}};this.getChartState=()=>a,Object.keys(a).forEach(e=>{this[e]=function(t){return arguments.length?(a[e]=t,this):a[e]}}),this.initializeEnterExitUpdatePattern()}initializeEnterExitUpdatePattern(){u.selection.prototype.patternify=function(t){var e=t.selector,a=t.tag,t=t.data||[e],t=this.selectAll("."+e).data(t,(t,e)=>"object"==typeof t&&t.id?t.id:e);return t.exit().remove(),(t=t.enter().append(a).merge(t)).attr("class",e),t}}getNodeChildren({data:t,children:e,_children:a},n){return n.push(t),e&&e.forEach(t=>{this.getNodeChildren(t,n)}),a&&a.forEach(t=>{this.getNodeChildren(t,n)}),n}initialZoom(t){return this.getChartState().lastTransform.k=t,this}render(){const o=this.getChartState();if(o.data&&0!=o.data.length){var t=u.select(o.container),e=t.node().getBoundingClientRect();0<e.width&&(o.svgWidth=e.width);const a={id:"ID"+Math.floor(1e6*Math.random()),chartWidth:o.svgWidth,chartHeight:o.svgHeight};(o.calc=a).centerX=a.chartWidth/2,a.centerY=a.chartHeight/2,o.firstDraw&&((e={zoom:null}).zoom=u.zoom().on("start",(t,e)=>o.onZoomStart(t,e)).on("end",(t,e)=>o.onZoomEnd(t,e)).on("zoom",(t,e)=>{o.onZoom(t,e),this.zoomed(t,e)}).scaleExtent(o.scaleExtent),o.zoomBehavior=e.zoom),o.flexTreeLayout=r.flextree({nodeSize:t=>{var e=o.nodeWidth(t),a=o.nodeHeight(t),n=o.siblingsMargin(t),i=o.childrenMargin(t);return o.layoutBindings[o.layout].nodeFlexSize({state:o,node:t,width:e,height:a,siblingsMargin:n,childrenMargin:i})}}).spacing((t,e)=>t.parent==e.parent?0:o.neighbourMargin(t,e)),this.setLayouts({expandNodesFirst:!1});e=t.patternify({tag:"svg",selector:"svg-chart-container"}).attr("width",o.svgWidth).attr("height",o.svgHeight).attr("font-family",o.defaultFont),t=(o.firstDraw&&e.call(o.zoomBehavior).on("dblclick.zoom",null).attr("cursor","move"),(o.svg=e).patternify({tag:"g",selector:"chart"}));o.centerG=t.patternify({tag:"g",selector:"center-group"}),o.linksWrapper=o.centerG.patternify({tag:"g",selector:"links-wrapper"}),o.nodesWrapper=o.centerG.patternify({tag:"g",selector:"nodes-wrapper"}),o.connectionsWrapper=o.centerG.patternify({tag:"g",selector:"connections-wrapper"}),o.defsWrapper=e.patternify({tag:"g",selector:"defs-wrapper"}),o.firstDraw&&o.centerG.attr("transform",()=>o.layoutBindings[o.layout].centerTransform({centerX:a.centerX,centerY:a.centerY,scale:o.lastTransform.k,rootMargin:o.rootMargin,root:o.root,chartHeight:a.chartHeight,chartWidth:a.chartWidth})),o.chart=t,this.update(o.root),u.select(window).on("resize."+o.id,()=>{var t=u.select(o.container).node().getBoundingClientRect();o.svg.attr("width",t.width)}),o.firstDraw&&(o.firstDraw=!1)}else console.log("ORG CHART - Data is empty");return this}addNode(e){const a=this.getChartState();var t=a.allNodes.filter(({data:t})=>a.nodeId(t)===a.nodeId(e))[0],n=a.allNodes.filter(({data:t})=>a.nodeId(t)===a.parentNodeId(e))[0];return t?console.log(`ORG CHART - ADD - Node with id "${a.nodeId(e)}" already exists in tree`):n?(e._centered&&!e._expanded&&(e._expanded=!0),a.data.push(e),this.updateNodesState()):console.log(`ORG CHART - ADD - Parent node with id "${a.parentNodeId(e)}" not found in the tree`),this}removeNode(e){const a=this.getChartState();var t=a.allNodes.filter(({data:t})=>a.nodeId(t)==e)[0];return t?(t.descendants().forEach(t=>t.data._filteredOut=!0),this.getNodeChildren(t,[],a.nodeId).forEach(t=>t._filtered=!0),a.data=a.data.filter(t=>!t._filtered),this.updateNodesState.bind(this)()):console.log(`ORG CHART - REMOVE - Node with id "${e}" not found in the tree`),this}groupBy(t,a,e){const n={};return t.forEach(t=>{var e=a(t);n[e]||(n[e]=[]),n[e].push(t)}),Object.keys(n).forEach(t=>{n[t]=e(n[t])}),Object.entries(n)}calculateCompactFlexDimensions(t){const r=this.getChartState();t.eachBefore(t=>{t.firstCompact=null,t.compactEven=null,t.flexCompactDim=null,t.firstCompactNode=null}),t.eachBefore(t=>{if(t.children&&1<t.children.length){const n=t.children.filter(t=>!t.children);if(!(n.length<2)){n.forEach((t,e)=>{e||(t.firstCompact=!0),t.compactEven=!(e%2),t.row=Math.floor(e/2)});var e=u.max(n.filter(t=>t.compactEven),r.layoutBindings[r.layout].compactDimension.sizeColumn),a=u.max(n.filter(t=>!t.compactEven),r.layoutBindings[r.layout].compactDimension.sizeColumn);const i=2*Math.max(e,a);e=this.groupBy(n,t=>t.row,t=>u.max(t,t=>r.layoutBindings[r.layout].compactDimension.sizeRow(t)+r.compactMarginBetween(t)));const o=u.sum(e.map(t=>t[1]));n.forEach(t=>{t.firstCompactNode=n[0],t.firstCompact?t.flexCompactDim=[i+r.compactMarginPair(t),o-r.compactMarginBetween(t)]:t.flexCompactDim=[0,0]}),t.flexCompactDim=null}}})}calculateCompactFlexPositions(t){const r=this.getChartState();t.eachBefore(t=>{if(t.children){var e=t.children.filter(t=>t.flexCompactDim);const n=e[0];if(n){e.forEach((t,e,a)=>{0==e&&(n.x-=n.flexCompactDim[0]/2),e&e%2-1?t.x=n.x+.25*n.flexCompactDim[0]-r.compactMarginPair(t)/4:e&&(t.x=n.x+.75*n.flexCompactDim[0]+r.compactMarginPair(t)/4)});var a=n.x+.5*n.flexCompactDim[0];n.x=n.x+.25*n.flexCompactDim[0]-r.compactMarginPair(n)/4;const i=t.x-a;Math.abs(i)<10&&e.forEach(t=>t.x+=i);t=this.groupBy(e,t=>t.row,t=>u.max(t,t=>r.layoutBindings[r.layout].compactDimension.sizeRow(t)));const o=u.cumsum(t.map(t=>t[1]+r.compactMarginBetween(t)));e.forEach((t,e)=>{t.row?t.y=n.y+o[t.row-1]:t.y=n.y})}}})}update({x0:a,y0:n,x:i=0,y:o=0,width:r,height:d}){const s=this.getChartState();s.calc;s.compact&&this.calculateCompactFlexDimensions(s.root);var t=s.flexTreeLayout(s.root),e=(s.compact&&this.calculateCompactFlexPositions(s.root),t.descendants()),t=t.descendants().slice(1),l=(e.forEach(s.layoutBindings[s.layout].swap),s.connections);const h={},c=(s.allNodes.forEach(t=>h[s.nodeId(t.data)]=t),{});e.forEach(t=>c[s.nodeId(t.data)]=t),l.forEach(t=>{var e=h[t.from],a=h[t.to];t._source=e,t._target=a});var l=l.filter(t=>c[t.from]&&c[t.to]),g=s.defs.bind(this)(s,l),g=(g!==s.defsWrapper.html()&&s.defsWrapper.html(g),s.linksWrapper.selectAll("path.link").data(t,t=>s.nodeId(t.data))),t=g.enter().insert("path","g").attr("class","link").attr("d",t=>{var e={x:s.layoutBindings[s.layout].linkJoinX({x:a,y:n,width:r,height:d}),y:s.layoutBindings[s.layout].linkJoinY({x:a,y:n,width:r,height:d})};return s.layoutBindings[s.layout].diagonal(e,e,e)}).merge(g),t=(t.attr("fill","none"),this.isEdge()?t.style("display",t=>{return t.data._pagingButton?"none":"auto"}):t.attr("display",t=>{return t.data._pagingButton?"none":"auto"}),t.each(s.linkUpdate),t.transition().duration(s.duration).attr("d",t=>{var e=s.compact&&t.flexCompactDim?{x:s.layoutBindings[s.layout].compactLinkMidX(t,s),y:s.layoutBindings[s.layout].compactLinkMidY(t,s)}:{x:s.layoutBindings[s.layout].linkX(t),y:s.layoutBindings[s.layout].linkY(t)},a={x:s.layoutBindings[s.layout].linkParentX(t),y:s.layoutBindings[s.layout].linkParentY(t)},t=s.compact&&t.flexCompactDim?{x:s.layoutBindings[s.layout].linkCompactXStart(t),y:s.layoutBindings[s.layout].linkCompactYStart(t)}:e;return s.layoutBindings[s.layout].diagonal(e,a,t,{sy:s.linkYOffset})}),g.exit().transition().duration(s.duration).attr("d",t=>{var e={x:s.layoutBindings[s.layout].linkJoinX({x:i,y:o,width:r,height:d}),y:s.layoutBindings[s.layout].linkJoinY({x:i,y:o,width:r,height:d})};return s.layoutBindings[s.layout].diagonal(e,e,null,{sy:s.linkYOffset})}).remove(),s.connectionsWrapper.selectAll("path.connection").data(l)),g=t.enter().insert("path","g").attr("class","connection").attr("d",t=>{var e={x:s.layoutBindings[s.layout].linkJoinX({x:a,y:n,width:r,height:d}),y:s.layoutBindings[s.layout].linkJoinY({x:a,y:n,width:r,height:d})};return s.layoutBindings[s.layout].diagonal(e,e,null,{sy:s.linkYOffset})}).merge(t),l=(g.attr("fill","none"),g.transition().duration(s.duration).attr("d",t=>{var e=s.layoutBindings[s.layout].linkX({x:t._source.x,y:t._source.y,width:t._source.width,height:t._source.height}),a=s.layoutBindings[s.layout].linkY({x:t._source.x,y:t._source.y,width:t._source.width,height:t._source.height}),n=s.layoutBindings[s.layout].linkJoinX({x:t._target.x,y:t._target.y,width:t._target.width,height:t._target.height}),t=s.layoutBindings[s.layout].linkJoinY({x:t._target.x,y:t._target.y,width:t._target.width,height:t._target.height});return s.linkGroupArc({source:{x:e,y:a},target:{x:n,y:t}})}),g.each(s.connectionsUpdate),t.exit().transition().duration(s.duration).attr("opacity",0).remove(),s.nodesWrapper.selectAll("g.node").data(e,({data:t})=>s.nodeId(t))),g=l.enter().append("g").attr("class","node").attr("transform",t=>{return t==s.root?`translate(${a},${n})`:`translate(${s.layoutBindings[s.layout].nodeJoinX({x:a,y:n,width:r,height:d})},${s.layoutBindings[s.layout].nodeJoinY({x:a,y:n,width:r,height:d})})`}).attr("cursor","pointer").on("click",(t,e)=>{var a=e["data"];[...t.srcElement.classList].includes("node-button-foreign-object")||([...t.srcElement.classList].includes("paging-button-wrapper")?this.loadPagingNodes(e):a._pagingButton?console.log("event fired, no handlers"):(s.onNodeClick(a),console.log("node clicked")))}),t=(g.patternify({tag:"rect",selector:"node-rect",data:t=>[t]}),g.merge(l).style("font","12px sans-serif")),g=(t.patternify({tag:"foreignObject",selector:"node-foreign-object",data:t=>[t]}).style("overflow","visible").patternify({tag:"xhtml:div",selector:"node-foreign-object-div",data:t=>[t]}),this.restyleForeignObjectElements(),g.patternify({tag:"g",selector:"node-button-g",data:t=>[t]}).on("click",(t,e)=>this.onButtonClick(t,e))),g=(g.patternify({tag:"rect",selector:"node-button-rect",data:t=>[t]}).attr("opacity",0).attr("pointer-events","all").attr("width",t=>s.nodeButtonWidth(t)).attr("height",t=>s.nodeButtonHeight(t)).attr("x",t=>s.nodeButtonX(t)).attr("y",t=>s.nodeButtonY(t)),g.patternify({tag:"foreignObject",selector:"node-button-foreign-object",data:t=>[t]}).attr("width",t=>s.nodeButtonWidth(t)).attr("height",t=>s.nodeButtonHeight(t)).attr("x",t=>s.nodeButtonX(t)).attr("y",t=>s.nodeButtonY(t)).style("overflow","visible").patternify({tag:"xhtml:div",selector:"node-button-div",data:t=>[t]}).style("pointer-events","none").style("display","flex").style("width","100%").style("height","100%"),t.transition().attr("opacity",0).duration(s.duration).attr("transform",({x:t,y:e,width:a,height:n})=>s.layoutBindings[s.layout].nodeUpdateTransform({x:t,y:e,width:a,height:n})).attr("opacity",1),t.select(".node-rect").attr("width",({width:t})=>t).attr("height",({height:t})=>t).attr("x",({})=>0).attr("y",({})=>0).attr("cursor","pointer").attr("rx",3).attr("fill",s.nodeDefaultBackground),t.select(".node-button-g").attr("transform",({width:t,height:e})=>{return`translate(${s.layoutBindings[s.layout].buttonX({width:t,height:e})},${s.layoutBindings[s.layout].buttonY({width:t,height:e})})`}).attr("display",({data:t})=>0<t._directSubordinates?null:"none").attr("opacity",({data:t,children:e,_children:a})=>!t._pagingButton&&(e||a)?1:0),t.select(".node-button-foreign-object .node-button-div").html(t=>s.buttonContent({node:t,state:s})),t.select(".node-button-text").attr("text-anchor","middle").attr("alignment-baseline","middle").attr("font-size",({children:t})=>t?40:26).text(({children:t})=>t?"-":"+").attr("y",this.isEdge()?10:0),t.each(s.nodeUpdate),l.exit().attr("opacity",1).transition().duration(s.duration).attr("transform",t=>{return`translate(${s.layoutBindings[s.layout].nodeJoinX({x:i,y:o,width:r,height:d})},${s.layoutBindings[s.layout].nodeJoinY({x:i,y:o,width:r,height:d})})`}).on("end",function(){u.select(this).remove()}).attr("opacity",0),e.forEach(t=>{t.x0=t.x,t.y0=t.y}),s.allNodes.filter(t=>t.data._centered)[0]);if(g){let t=[g];g.data._centeredWithDescendants&&(t=s.compact?g.descendants().filter((t,e)=>e<7):g.descendants().filter((t,e,a)=>{var n=Math.round(a.length/2);return a.length%2?n-2<e&&e<n+2-1:n-2<e&&e<n+2})),g.data._centeredWithDescendants=null,g.data._centered=null,this.fit({animate:!0,scale:!1,nodes:t})}}isEdge(){return window.navigator.userAgent.includes("Edge")}hdiagonal(t,e,a,n){return this.getChartState().hdiagonal(t,e,a,n)}diagonal(t,e,a,n){return this.getChartState().diagonal(t,e,a,n)}restyleForeignObjectElements(){const n=this.getChartState();n.svg.selectAll(".node-foreign-object").attr("width",({width:t})=>t).attr("height",({height:t})=>t).attr("x",({})=>0).attr("y",({})=>0),n.svg.selectAll(".node-foreign-object-div").style("width",({width:t})=>t+"px").style("height",({height:t})=>t+"px").html(function(t,e,a){return t.data._pagingButton?`<div class="paging-button-wrapper"><div style="pointer-events:none">${n.pagingButton(t,e,a,n)}</div></div>`:n.nodeContent.bind(this)(t,e,a,n)})}onButtonClick(t,e){var a=this.getChartState();e.data._pagingButton||(a.setActiveNodeCentered&&(e.data._centered=!0,e.data._centeredWithDescendants=!0),e.children?(e._children=e.children,e.children=null,this.setExpansionFlagToChildren(e,!1)):(e.children=e._children,e._children=null,e.children&&e.children.forEach(({data:t})=>t._expanded=!0)),this.update(e))}setExpansionFlagToChildren({data:t,children:e,_children:a},n){t._expanded=n,e&&e.forEach(t=>{this.setExpansionFlagToChildren(t,n)}),a&&a.forEach(t=>{this.setExpansionFlagToChildren(t,n)})}expandSomeNodes(e){if(e.data._expanded){let t=e.parent;for(;t;)t._children&&(t.children=t._children),t=t.parent}e._children&&e._children.forEach(t=>this.expandSomeNodes(t)),e.children&&e.children.forEach(t=>this.expandSomeNodes(t))}updateNodesState(){var t=this.getChartState();this.setLayouts({expandNodesFirst:!0}),this.update(t.root)}setLayouts({expandNodesFirst:t=!0}){const o=this.getChartState(),n=(o.root=u.stratify().id(t=>o.nodeId(t)).parentId(t=>o.parentNodeId(t))(o.data),{});o.root.descendants().filter(t=>t.children).filter(t=>!t.data._pagingStep).forEach(t=>{t.data._pagingStep=o.minPagingVisibleNodes(t)}),o.root.eachBefore((a,t)=>{a.data._directSubordinatesPaging=a.children?a.children.length:0,a.children&&a.children.forEach((t,e)=>{t.data._pagingButton=!1,e>a.data._pagingStep&&(n[t.id]=!0),e===a.data._pagingStep&&a.children.length-1>a.data._pagingStep&&(t.data._pagingButton=!0),n[t.parent.id]&&(n[t.id]=!0)})}),o.root=u.stratify().id(t=>o.nodeId(t)).parentId(t=>o.parentNodeId(t))(o.data.filter(t=>!0!==n[t.id])),o.root.each((t,e,a)=>{var n=o.nodeWidth(t),i=o.nodeHeight(t);Object.assign(t,{width:n,height:i})}),o.root.x0=0,o.root.y0=0,o.allNodes=o.root.descendants(),o.allNodes.forEach(t=>{Object.assign(t.data,{_directSubordinates:t.children?t.children.length:0,_totalSubordinates:t.descendants().length-1})}),o.root.children&&(t&&o.root.children.forEach(this.expand),o.root.children.forEach(t=>this.collapse(t)),0==o.expandLevel&&(o.root._children=o.root.children,o.root.children=null),[o.root].forEach(t=>this.expandSomeNodes(t)))}collapse(t){t.children&&(t._children=t.children,t._children.forEach(t=>this.collapse(t)),t.children=null)}expand(t){t._children&&(t.children=t._children,t.children.forEach(t=>this.expand(t)),t._children=null)}zoomed(t,e){var a=this.getChartState(),n=a.chart,t=t.transform;a.lastTransform=t,n.attr("transform",t),this.isEdge()&&this.restyleForeignObjectElements()}zoomTreeBounds({x0:t,x1:e,y0:a,y1:n,params:i={animate:!0,scale:!0}}){var{centerG:o,svgWidth:r,svgHeight:d,svg:s,zoomBehavior:l,duration:h,lastTransform:c}=this.getChartState(),g=Math.min(8,.9/Math.max((e-t)/r,(n-a)/d));let p=u.zoomIdentity.translate(r/2,d/2);p=(p=p.scale(i.scale?g:c.k)).translate(-(t+e)/2,-(a+n)/2),s.transition().duration(i.animate?h:0).call(l.transform,p),o.transition().duration(i.animate?h:0).attr("transform","translate(0,0)")}fit({animate:t=!0,nodes:e,scale:a=!0}={}){const n=this.getChartState();var i=n["root"],e=e||i.descendants(),i=u.min(e,t=>t.x+n.layoutBindings[n.layout].nodeLeftX(t)),o=u.max(e,t=>t.x+n.layoutBindings[n.layout].nodeRightX(t)),r=u.min(e,t=>t.y+n.layoutBindings[n.layout].nodeTopY(t)),e=u.max(e,t=>t.y+n.layoutBindings[n.layout].nodeBottomY(t));return this.zoomTreeBounds({params:{animate:t,scale:a},x0:i-50,x1:o+50,y0:r-50,y1:e+50}),this}loadPagingNodes(t){var e=this.getChartState(),a=(t.data._pagingButton=!1,t.parent.data._pagingStep),e=e.pagingStep(t.parent);t.parent.data._pagingStep=a+e,console.log("loading paging nodes",t),this.updateNodesState()}setExpanded(e,t=!0){const a=this.getChartState();var n=a.allNodes.filter(({data:t})=>a.nodeId(t)==e)[0];return n?n.data._expanded=t:console.log(`ORG CHART - ${t?"EXPAND":"COLLAPSE"} - Node with id (${e})  not found in the tree`),this}setCentered(e){const a=this.getChartState();var t=a.allNodes.filter(t=>a.nodeId(t.data)===e)[0];return t?(t.data._centered=!0,t.data._expanded=!0):console.log(`ORG CHART - CENTER - Node with id (${e}) not found in the tree`),this}setHighlighted(e){const a=this.getChartState();var t=a.allNodes.filter(t=>a.nodeId(t.data)===e)[0];return t?(t.data._highlighted=!0,t.data._expanded=!0,t.data._centered=!0):console.log(`ORG CHART - HIGHLIGHT - Node with id (${e})  not found in the tree`),this}setUpToTheRootHighlighted(e){const a=this.getChartState();var t=a.allNodes.filter(t=>a.nodeId(t.data)===e)[0];return t?(t.data._upToTheRootHighlighted=!0,t.data._expanded=!0,t.ancestors().forEach(t=>t.data._upToTheRootHighlighted=!0)):console.log(`ORG CHART - HIGHLIGHTROOT - Node with id (${e}) not found in the tree`),this}clearHighlighting(){var t=this.getChartState();t.allNodes.forEach(t=>{t.data._highlighted=!1,t.data._upToTheRootHighlighted=!1}),this.update(t.root)}fullscreen(t){const e=this.getChartState(),a=u.select(t||e.container).node();u.select(document).on("fullscreenchange."+e.id,function(t){(document.fullscreenElement||document.mozFullscreenElement||document.webkitFullscreenElement)==a?setTimeout(t=>{e.svg.attr("height",window.innerHeight-40)},500):e.svg.attr("height",e.svgHeight)}),a.requestFullscreen?a.requestFullscreen():a.mozRequestFullScreen?a.mozRequestFullScreen():a.webkitRequestFullscreen?a.webkitRequestFullscreen():a.msRequestFullscreen&&a.msRequestFullscreen()}zoomIn(){var{svg:t,zoomBehavior:e}=this.getChartState();t.transition().call(e.scaleBy,1.3)}zoomOut(){var{svg:t,zoomBehavior:e}=this.getChartState();t.transition().call(e.scaleBy,.78)}toDataURL(t,e){var a=new XMLHttpRequest;a.onload=function(){var t=new FileReader;t.onloadend=function(){e(t.result)},t.readAsDataURL(a.response)},a.open("GET",t),a.responseType="blob",a.send()}exportImg({full:a=!1,scale:n=3,onLoad:i=t=>t,save:o=!0}={}){const r=this,d=this.getChartState(),{svg:t,root:s}=d;let e=0;var l=t.selectAll("img");let h=l.size();const c=()=>{JSON.parse(JSON.stringify(r.lastTransform()));var t=r.duration();a&&r.fit();const e=r.getChartState()["svg"];setTimeout(t=>{r.downloadImage({node:e.node(),scale:n,isSvg:!1,onAlreadySerialized:t=>{r.update(s)},imageName:d.imageName,onLoad:i,save:o})},a?t+10:0)};0<h?l.each(function(){r.toDataURL(this.src,t=>{this.src=t,++e==h&&c()})}):c()}exportSvg(){var{svg:t,imageName:e}=this.getChartState();return this.downloadImage({imageName:e,node:t.node(),scale:3,isSvg:!0}),this}expandAll(){var t=this.getChartState()["allNodes"];return t.forEach(t=>t.data._expanded=!0),this.render(),this}collapseAll(){var t=this.getChartState()["allNodes"];return t.forEach(t=>t.data._expanded=!1),this.expandLevel(0),this.render(),this}downloadImage({node:t,scale:e=2,imageName:n="graph",isSvg:a=!1,save:i=!0,onAlreadySerialized:o=t=>{},onLoad:r=t=>{}}){const d=t;if(a)t='<?xml version="1.0" standalone="no"?>\r\n'+(t=h(d)),l(s="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(t),n+".svg"),o();else{const c=e,g=document.createElement("img");g.onload=function(){var t=document.createElement("canvas"),e=d.getBoundingClientRect(),a=(t.width=e.width*c,t.height=e.height*c,t.getContext("2d")),a=(a.fillStyle="#FAFAFA",a.fillRect(0,0,e.width*c,e.height*c),a.drawImage(g,0,0,e.width*c,e.height*c),t.toDataURL("image/png"));r&&r(a),i&&l(a,n+".png")};var s="data:image/svg+xml; charset=utf8, "+encodeURIComponent(h(d));function l(t,e){var a=document.createElement("a");"string"==typeof a.download?(document.body.appendChild(a),a.download=e,a.href=t,a.click(),document.body.removeChild(a)):location.replace(t)}function h(t){for(var e="http://www.w3.org/2000/xmlns/",a=(t=t.cloneNode(!0),window.location.href+"#"),n=document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT,null,!1);n.nextNode();)for(const i of n.currentNode.attributes)i.value.includes(a)&&(i.value=i.value.replace(a,"#"));return t.setAttributeNS(e,"xmlns","http://www.w3.org/2000/svg"),t.setAttributeNS(e,"xmlns:xlink","http://www.w3.org/1999/xlink"),(new XMLSerializer).serializeToString(t)}o(),g.src=s}}getTextWidth(t,{fontSize:e=14,fontWeight:a=400,defaultFont:n="Helvetice",ctx:i}={}){return i.font=`${a||""} ${e}px ${n} `,i.measureText(t).width}},Object.defineProperty(t,"__esModule",{value:!0})});
\ No newline at end of file
diff --git a/node_modules/d3-org-chart/index.js b/node_modules/d3-org-chart/index.js
index fe34324..a278e83 100644
--- a/node_modules/d3-org-chart/index.js
+++ b/node_modules/d3-org-chart/index.js
@@ -1,2 +1 @@
 export { OrgChart } from "./src/d3-org-chart"; 
- 
\ No newline at end of file
diff --git a/node_modules/d3-org-chart/src/d3-org-chart.js b/node_modules/d3-org-chart/src/d3-org-chart.js
index 871f2d8..bacf61e 100644
--- a/node_modules/d3-org-chart/src/d3-org-chart.js
+++ b/node_modules/d3-org-chart/src/d3-org-chart.js
@@ -1,104 +1,148 @@
-import { selection, select } from "d3-selection";
-import { max, min, sum, cumsum } from "d3-array";
-import { tree, stratify } from "d3-hierarchy";
-import { zoom, zoomIdentity } from "d3-zoom";
+/* eslint-disable @typescript-eslint/no-this-alias */
+import { selection, select } from 'd3-selection';
+import { max, min, sum, cumsum } from 'd3-array';
+import { tree, stratify } from 'd3-hierarchy';
+import { zoom, zoomIdentity } from 'd3-zoom';
 import { flextree } from 'd3-flextree';
 import { linkHorizontal } from 'd3-shape';
+import apiService from "../../../src/utils/apiService"
 
 const d3 = {
-    selection,
-    select,
-    max,
-    min,
-    sum,
-    cumsum,
-    tree,
-    stratify,
-    zoom,
-    zoomIdentity,
-    linkHorizontal,
-}
+  selection,
+  select,
+  max,
+  min,
+  sum,
+  cumsum,
+  tree,
+  stratify,
+  zoom,
+  zoomIdentity,
+  linkHorizontal,
+};
 export class OrgChart {
-    constructor() {
-        // Exposed variables 
-        const attrs = {
-            id: `ID${Math.floor(Math.random() * 1000000)}`, // Id for event handlings
-            firstDraw: true,
-            svgWidth: 800,
-            svgHeight: window.innerHeight - 100,
-            scaleExtent:[0.001, 20],
-            container: "body",
-            defaultTextFill: "#2C3E50",
-            defaultFont: "Helvetica",
-            ctx: document.createElement('canvas').getContext('2d'),
-            data: null,
-            duration: 400,
-            setActiveNodeCentered: true,
-            expandLevel: 1,
-            compact: true,
-            rootMargin: 40,
-            nodeDefaultBackground: 'none',
-            connections: [],
-            lastTransform: { x: 0, y: 0, k: 1 },
-            nodeId: d => d.nodeId || d.id,
-            parentNodeId: d => d.parentNodeId || d.parentId,
-            backgroundColor: 'none',
-            zoomBehavior: null,
-            defs: function (state, visibleConnections) {
-                return `<defs>
-                    ${visibleConnections.map(conn => {
-                    const labelWidth = this.getTextWidth(conn.label, { ctx: state.ctx, fontSize: 2, defaultFont: state.defaultFont });
-                    return `
-                       <marker id="${conn.from + "_" + conn.to}" refX="${conn._source.x < conn._target.x ? -7 : 7}" refY="5" markerWidth="500"  markerHeight="500"  orient="${conn._source.x < conn._target.x ? "auto" : "auto-start-reverse"}" >
-                       <rect rx=0.5 width=${conn.label ? labelWidth + 3 : 0} height=3 y=1  fill="#152785"></rect>
-                       <text font-size="2px" x=1 fill="white" y=3>${conn.label || ''}</text>
+  constructor() {
+    // Exposed variables
+    const attrs = {
+      id: `ID${Math.floor(Math.random() * 1000000)}`, // Id for event handlings
+      firstDraw: true,
+      svgWidth: 800,
+      svgHeight: window.innerHeight - 100,
+      scaleExtent: [0.001, 20],
+      container: 'body',
+      defaultTextFill: '#2C3E50',
+      defaultFont: 'Helvetica',
+      ctx: document.createElement('canvas').getContext('2d'),
+      data: null,
+      duration: 400,
+      setActiveNodeCentered: true,
+      expandLevel: 1,
+      compact: true,
+      rootMargin: 40,
+      nodeDefaultBackground: 'none',
+      connections: [],
+      lastTransform: { x: 0, y: 0, k: 1 },
+      nodeId: (d) => d.nodeId || d.id,
+      parentNodeId: (d) => d.parentNodeId || d.parentId,
+      backgroundColor: 'none',
+      zoomBehavior: null,
+      defs: function (state, visibleConnections) {
+        return `<defs>
+                    ${visibleConnections
+                      .map((conn) => {
+                        const labelWidth = this.getTextWidth(conn.label, {
+                          ctx: state.ctx,
+                          fontSize: 2,
+                          defaultFont: state.defaultFont,
+                        });
+                        return `
+                       <marker id="${conn.from + '_' + conn.to}" refX="${
+                          conn._source.x < conn._target.x ? -7 : 7
+                        }" refY="5" markerWidth="500"  markerHeight="500"  orient="${
+                          conn._source.x < conn._target.x
+                            ? 'auto'
+                            : 'auto-start-reverse'
+                        }" >
+                       <rect rx=0.5 width=${
+                         conn.label ? labelWidth + 3 : 0
+                       } height=3 y=1  fill="#152785"></rect>
+                       <text font-size="2px" x=1 fill="white" y=3>${
+                         conn.label || ''
+                       }</text>
                        </marker>
 
-                       <marker id="arrow-${conn.from + "_" + conn.to}"  markerWidth="500"  markerHeight="500"  refY="2"  refX="1" orient="${conn._source.x < conn._target.x ? "auto" : "auto-start-reverse"}" >
+                       <marker id="arrow-${
+                         conn.from + '_' + conn.to
+                       }"  markerWidth="500"  markerHeight="500"  refY="2"  refX="1" orient="${
+                          conn._source.x < conn._target.x
+                            ? 'auto'
+                            : 'auto-start-reverse'
+                        }" >
                        <path transform="translate(0)" d='M0,0 V4 L2,2 Z' fill='#152785' />
                        </marker>
-                    `}).join("")}
+                    `;
+                      })
+                      .join('')}
                     </defs>
-                    `},
-            connectionsUpdate: function (d, i, arr) {
-                d3.select(this)
-                    .attr("stroke", d => '#152785')
-                    .attr('stroke-linecap', 'round')
-                    .attr("stroke-width", d => '5')
-                    .attr('pointer-events', 'none')
-                    .attr("marker-start", d => `url(#${d.from + "_" + d.to})`)
-                    .attr("marker-end", d => `url(#arrow-${d.from + "_" + d.to})`)
-            },
-            linkUpdate: function (d, i, arr) {
-                d3.select(this)
-                    .attr("stroke", d => d.data._upToTheRootHighlighted ? '#152785' : 'lightgray')
-                    .attr("stroke-width", d => d.data._upToTheRootHighlighted ? 5 : 2)
-
-                if (d.data._upToTheRootHighlighted) {
-                    d3.select(this).raise()
-                }
-            },
-            nodeUpdate: function (d, i, arr) {
-                d3.select(this)
-                    .select('.node-rect')
-                    .attr("stroke", d => d.data._highlighted || d.data._upToTheRootHighlighted ? '#152785' : 'none')
-                    .attr("stroke-width", d.data._highlighted || d.data._upToTheRootHighlighted ? 10 : 1)
-            },
-
-            nodeWidth: d3Node => 250,
-            nodeHeight: d => 150,
-            siblingsMargin: d3Node => 20,
-            childrenMargin: d => 60,
-            neightbourMargin: (n1, n2) => 80,
-            compactMarginPair: d => 100,
-            compactMarginBetween: (d3Node => 20),
-            onNodeClick: (d) => d,
-            linkGroupArc: d3.linkHorizontal().x(d => d.x).y(d => d.y),
-            // ({ source, target }) => {
-            //     return 
-            //     return `M ${source.x} , ${source.y} Q ${(source.x + target.x) / 2 + 100},${source.y-100}  ${target.x}, ${target.y}`;
-            // },
-            nodeContent: d => `<div style="padding:5px;font-size:10px;">Sample Node(id=${d.id}), override using <br/> <br/> 
+                    `;
+      },
+      connectionsUpdate: function (d, i, arr) {
+        d3.select(this)
+          .attr('stroke', (d) => '#152785')
+          .attr('stroke-linecap', 'round')
+          .attr('stroke-width', (d) => '5')
+          .attr('pointer-events', 'none')
+          .attr('marker-start', (d) => `url(#${d.from + '_' + d.to})`)
+          .attr('marker-end', (d) => `url(#arrow-${d.from + '_' + d.to})`);
+      },
+      linkUpdate: function (d, i, arr) {
+        d3.select(this)
+          .attr('stroke', (d) =>
+            d.data._upToTheRootHighlighted ? '#3F83F8' : 'lightgray',
+          )
+          .attr('stroke-width', (d) =>
+            d.data._upToTheRootHighlighted ? 1 : 1,
+          );
+
+        if (d.data._upToTheRootHighlighted) {
+          d3.select(this).raise();
+        }
+      },
+      nodeUpdate: function (d, i, arr) {
+        d3.select(this)
+          .select('.node-rect')
+          .attr('stroke', (d) =>
+            d.data._highlighted ||
+            (d.data._upToTheRootHighlighted &&
+              d.data._upToTheRootHighlightedNode)
+              ? '#3F83F8'
+              : 'none',
+          )
+          .attr(
+            'stroke-width',
+            d.data._highlighted || d.data._upToTheRootHighlighted ? 2 : 2,
+          );
+      },
+
+      nodeWidth: (d3Node) => 250,
+      nodeHeight: (d) => 150,
+      siblingsMargin: (d3Node) => 20,
+      childrenMargin: (d) => 60,
+      neightbourMargin: (n1, n2) => 80,
+      compactMarginPair: (d) => 100,
+      compactMarginBetween: (d3Node) => 20,
+      onNodeClick: (d) => d,
+      linkGroupArc: d3
+        .linkHorizontal()
+        .x((d) => d.x)
+        .y((d) => d.y),
+      // ({ source, target }) => {
+      //     return
+      //     return `M ${source.x} , ${source.y} Q ${(source.x + target.x) / 2 + 100},${source.y-100}  ${target.x}, ${target.y}`;
+      // },
+      nodeContent: (
+        d,
+      ) => `<div style="padding:5px;font-size:10px;">Sample Node(id=${d.id}), override using <br/> <br/> 
             <code>chart<br/>
             &nbsp;.nodeContent({data}=>{ <br/>
              &nbsp;&nbsp;&nbsp;&nbsp;return '' // Custom HTML <br/>
@@ -107,928 +151,1280 @@ export class OrgChart {
              Or check different <a href="https://github.com/bumbeishvili/org-chart#jump-to-examples" target="_blank">layout examples</a>
              
              </div>`,
-            layout: "top",// top, left,right, bottom
-            buttonContent: ({ node, state }) => {
-                const icons = {
-                    "left": d => d ? `<div style="margin-top:-10px;line-height:1.2;font-size:25px;height:22px"></div>` : `<div style="margin-top:-10px;font-size:25px;height:23px"></div>`,
-                    "bottom": d => d ? `<div style="margin-top:-20px;font-size:25px"></div>` : `<div style="margin-top:0px;line-height:1.2;height:11px;font-size:25px"></div>`,
-                    "right": d => d ? `<div style="margin-top:-10px;font-size:25px;height:23px"></div>` : `<div style="margin-top:-10px;line-height:1.2;font-size:25px;height:22px"></div>`,
-                    "top": d => d ? `<div style="margin-top:0px;line-height:1.2;height:11px;font-size:25px"></div>` : `<div style="margin-top:-20px;font-size:25px"></div>`,
-                }
-                return `<div style="border-radius:3px;padding:3px;font-size:10px;margin:auto auto;background-color:lightgray"> ${icons[state.layout](node.children)}  </div>`
-            },
-            layoutBindings: {
-                "left": {
-                    "nodeLeftX": node => 0,
-                    "nodeRightX": node => node.width,
-                    "nodeTopY": node => - node.height / 2,
-                    "nodeBottomY": node => node.height / 2,
-                    "nodeJoinX": node => node.x + node.width,
-                    "nodeJoinY": node => node.y - node.height / 2,
-                    "linkJoinX": node => node.x + node.width,
-                    "linkJoinY": node => node.y,
-                    "linkX": node => node.x,
-                    "linkY": node => node.y,
-                    "linkCompactXStart": node => node.x + node.width / 2,//node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
-                    "linkCompactYStart": node => node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
-                    "compactLinkMidX": (node, state) => node.firstCompactNode.x,// node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
-                    "compactLinkMidY": (node, state) => node.firstCompactNode.y + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
-                    "linkParentX": node => node.parent.x + node.parent.width,
-                    "linkParentY": node => node.parent.y,
-                    "buttonX": node => node.width,
-                    "buttonY": node => node.height / 2,
-                    "centerTransform": ({ root, rootMargin, centerY, scale, centerX }) => `translate(${rootMargin},${centerY}) scale(${scale})`,
-                    "compactDimension": {
-                        sizeColumn: node => node.height,
-                        sizeRow: node => node.width,
-                        reverse: arr => arr.slice().reverse()
-                    },
-                    "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
-                        if (state.compact && node.flexCompactDim) {
-                            const result = [node.flexCompactDim[0], node.flexCompactDim[1]]
-                            return result;
-                        };
-                        return [height + siblingsMargin, width + childrenMargin]
-                    },
-                    "zoomTransform": ({ centerY, scale }) => `translate(${0},${centerY}) scale(${scale})`,
-                    "diagonal": this.hdiagonal.bind(this),
-                    "swap": d => { const x = d.x; d.x = d.y; d.y = x; },
-                    "nodeUpdateTransform": ({ x, y, width, height }) => `translate(${x},${y - height / 2})`,
-                },
-                "top": {
-                    "nodeLeftX": node => -node.width / 2,
-                    "nodeRightX": node => node.width / 2,
-                    "nodeTopY": node => 0,
-                    "nodeBottomY": node => node.height,
-                    "nodeJoinX": node => node.x - node.width / 2,
-                    "nodeJoinY": node => node.y + node.height,
-                    "linkJoinX": node => node.x,
-                    "linkJoinY": node => node.y + node.height,
-                    "linkCompactXStart": node => node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
-                    "linkCompactYStart": node => node.y + node.height / 2,
-                    "compactLinkMidX": (node, state) => node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
-                    "compactLinkMidY": node => node.firstCompactNode.y,
-                    "compactDimension": {
-                        sizeColumn: node => node.width,
-                        sizeRow: node => node.height,
-                        reverse: arr => arr,
-                    },
-                    "linkX": node => node.x,
-                    "linkY": node => node.y,
-                    "linkParentX": node => node.parent.x,
-                    "linkParentY": node => node.parent.y + node.parent.height,
-                    "buttonX": node => node.width / 2,
-                    "buttonY": node => node.height,
-                    "centerTransform": ({ root, rootMargin, centerY, scale, centerX }) => `translate(${centerX},${rootMargin}) scale(${scale})`,
-                    "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node, compactViewIndex }) => {
-                        if (state.compact && node.flexCompactDim) {
-                            const result = [node.flexCompactDim[0], node.flexCompactDim[1]]
-                            return result;
-                        };
-                        return [width + siblingsMargin, height + childrenMargin];
-                    },
-                    "zoomTransform": ({ centerX, scale }) => `translate(${centerX},0}) scale(${scale})`,
-                    "diagonal": this.diagonal.bind(this),
-                    "swap": d => { },
-                    "nodeUpdateTransform": ({ x, y, width, height }) => `translate(${x - width / 2},${y})`,
-
-                },
-                "bottom": {
-                    "nodeLeftX": node => -node.width / 2,
-                    "nodeRightX": node => node.width / 2,
-                    "nodeTopY": node => -node.height,
-                    "nodeBottomY": node => 0,
-                    "nodeJoinX": node => node.x - node.width / 2,
-                    "nodeJoinY": node => node.y - node.height - node.height,
-                    "linkJoinX": node => node.x,
-                    "linkJoinY": node => node.y - node.height,
-                    "linkCompactXStart": node => node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
-                    "linkCompactYStart": node => node.y - node.height / 2,
-                    "compactLinkMidX": (node, state) => node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
-                    "compactLinkMidY": node => node.firstCompactNode.y,
-                    "linkX": node => node.x,
-                    "linkY": node => node.y,
-                    "compactDimension": {
-                        sizeColumn: node => node.width,
-                        sizeRow: node => node.height,
-                        reverse: arr => arr,
-                    },
-                    "linkParentX": node => node.parent.x,
-                    "linkParentY": node => node.parent.y - node.parent.height,
-                    "buttonX": node => node.width / 2,
-                    "buttonY": node => 0,
-                    "centerTransform": ({ root, rootMargin, centerY, scale, centerX, chartHeight }) => `translate(${centerX},${chartHeight - rootMargin}) scale(${scale})`,
-                    "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
-                        if (state.compact && node.flexCompactDim) {
-                            const result = [node.flexCompactDim[0], node.flexCompactDim[1]]
-                            return result;
-                        };
-                        return [width + siblingsMargin, height + childrenMargin]
-                    },
-                    "zoomTransform": ({ centerX, scale }) => `translate(${centerX},0}) scale(${scale})`,
-                    "diagonal": this.diagonal.bind(this),
-                    "swap": d => { d.y = -d.y; },
-                    "nodeUpdateTransform": ({ x, y, width, height }) => `translate(${x - width / 2},${y - height})`,
-                },
-                "right": {
-                    "nodeLeftX": node => -node.width,
-                    "nodeRightX": node => 0,
-                    "nodeTopY": node => - node.height / 2,
-                    "nodeBottomY": node => node.height / 2,
-                    "nodeJoinX": node => node.x - node.width - node.width,
-                    "nodeJoinY": node => node.y - node.height / 2,
-                    "linkJoinX": node => node.x - node.width,
-                    "linkJoinY": node => node.y,
-                    "linkX": node => node.x,
-                    "linkY": node => node.y,
-                    "linkParentX": node => node.parent.x - node.parent.width,
-                    "linkParentY": node => node.parent.y,
-                    "buttonX": node => 0,
-                    "buttonY": node => node.height / 2,
-                    "linkCompactXStart": node => node.x - node.width / 2,//node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
-                    "linkCompactYStart": node => node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
-                    "compactLinkMidX": (node, state) => node.firstCompactNode.x,// node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
-                    "compactLinkMidY": (node, state) => node.firstCompactNode.y + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
-                    "centerTransform": ({ root, rootMargin, centerY, scale, centerX, chartWidth }) => `translate(${chartWidth - rootMargin},${centerY}) scale(${scale})`,
-                    "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
-                        if (state.compact && node.flexCompactDim) {
-                            const result = [node.flexCompactDim[0], node.flexCompactDim[1]]
-                            return result;
-                        };
-                        return [height + siblingsMargin, width + childrenMargin]
-                    },
-                    "compactDimension": {
-                        sizeColumn: node => node.height,
-                        sizeRow: node => node.width,
-                        reverse: arr => arr.slice().reverse()
-                    },
-                    "zoomTransform": ({ centerY, scale }) => `translate(${0},${centerY}) scale(${scale})`,
-                    "diagonal": this.hdiagonal.bind(this),
-                    "swap": d => { const x = d.x; d.x = -d.y; d.y = x; },
-                    "nodeUpdateTransform": ({ x, y, width, height }) => `translate(${x - width},${y - height / 2})`,
-                },
-            }
-        };
-
-        this.getChartState = () => attrs;
-
-        // Dynamically set getter and setter functions for Chart class
-        Object.keys(attrs).forEach((key) => {
-            //@ts-ignore
-            this[key] = function (_) {
-                if (!arguments.length) {
-                    return attrs[key];
-                } else {
-                    attrs[key] = _;
-                }
-                return this;
-            };
-        });
-
-        this.initializeEnterExitUpdatePattern();
-    }
-
-    initializeEnterExitUpdatePattern() {
-        d3.selection.prototype.patternify = function (params) {
-            var container = this;
-            var selector = params.selector;
-            var elementTag = params.tag;
-            var data = params.data || [selector];
-
-            // Pattern in action
-            var selection = container.selectAll("." + selector).data(data, (d, i) => {
-                if (typeof d === "object") {
-                    if (d.id) { return d.id; }
-                }
-                return i;
-            });
-            selection.exit().remove();
-            selection = selection.enter().append(elementTag).merge(selection);
-            selection.attr("class", selector);
-            return selection;
+      layout: 'top', // top, left,right, bottom
+      buttonContent: ({ node, state }) => {
+        const icons = {
+          left: (d) =>
+            d
+              ? `<div style="margin-top:-10px;line-height:1.2;font-size:25px;height:22px"></div>`
+              : `<div style="margin-top:-10px;font-size:25px;height:23px"></div>`,
+          bottom: (d) =>
+            d
+              ? `<div style="margin-top:-20px;font-size:25px"></div>`
+              : `<div style="margin-top:0px;line-height:1.2;height:11px;font-size:25px"></div>`,
+          right: (d) =>
+            d
+              ? `<div style="margin-top:-10px;font-size:25px;height:23px"></div>`
+              : `<div style="margin-top:-10px;line-height:1.2;font-size:25px;height:22px"></div>`,
+          top: (d) =>
+            d
+              ? `<div style="margin-top:0px;line-height:1.2;height:11px;font-size:25px"></div>`
+              : `<div style="margin-top:-20px;font-size:25px"></div>`,
         };
-    }
-
-    // This method retrieves passed node's children IDs (including node)
-    getNodeChildren({ data, children, _children }, nodeStore) {
-        // Store current node ID
-        nodeStore.push(data);
-
-        // Loop over children and recursively store descendants id (expanded nodes)
-        if (children) {
-            children.forEach((d) => {
-                this.getNodeChildren(d, nodeStore);
-            });
+        return `<div style="border-radius:3px;padding:3px;font-size:10px;margin:auto auto;background-color:lightgray"> ${icons[
+          state.layout
+        ](node.children)}  </div>`;
+      },
+      layoutBindings: {
+        left: {
+          nodeLeftX: (node) => 0,
+          nodeRightX: (node) => node.width,
+          nodeTopY: (node) => -node.height / 2,
+          nodeBottomY: (node) => node.height / 2,
+          nodeJoinX: (node) => node.x + node.width,
+          nodeJoinY: (node) => node.y - node.height / 2,
+          linkJoinX: (node) => node.x + node.width,
+          linkJoinY: (node) => node.y,
+          linkX: (node) => node.x,
+          linkY: (node) => node.y,
+          linkCompactXStart: (node) => node.x + node.width / 2, //node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
+          linkCompactYStart: (node) =>
+            node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
+          compactLinkMidX: (node, state) => node.firstCompactNode.x, // node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
+          compactLinkMidY: (node, state) =>
+            node.firstCompactNode.y +
+            node.firstCompactNode.flexCompactDim[0] / 4 +
+            state.compactMarginPair(node) / 4,
+          linkParentX: (node) => node.parent.x + node.parent.width,
+          linkParentY: (node) => node.parent.y,
+          buttonX: (node) => node.width,
+          buttonY: (node) => node.height / 2,
+          centerTransform: ({ root, rootMargin, centerY, scale, centerX }) =>
+            `translate(${rootMargin},${centerY}) scale(${scale})`,
+          compactDimension: {
+            sizeColumn: (node) => node.height,
+            sizeRow: (node) => node.width,
+            reverse: (arr) => arr.slice().reverse(),
+          },
+          nodeFlexSize: ({
+            height,
+            width,
+            siblingsMargin,
+            childrenMargin,
+            state,
+            node,
+          }) => {
+            if (state.compact && node.flexCompactDim) {
+              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
+              return result;
+            }
+            return [height + siblingsMargin, width + childrenMargin];
+          },
+          zoomTransform: ({ centerY, scale }) =>
+            `translate(${0},${centerY}) scale(${scale})`,
+          diagonal: this.hdiagonal.bind(this),
+          swap: (d) => {
+            const x = d.x;
+            d.x = d.y;
+            d.y = x;
+          },
+          nodeUpdateTransform: ({ x, y, width, height }) =>
+            `translate(${x},${y - height / 2})`,
+        },
+        top: {
+          nodeLeftX: (node) => -node.width / 2,
+          nodeRightX: (node) => node.width / 2,
+          nodeTopY: (node) => 0,
+          nodeBottomY: (node) => node.height,
+          nodeJoinX: (node) => node.x - node.width / 2,
+          nodeJoinY: (node) => node.y + node.height,
+          linkJoinX: (node) => node.x,
+          linkJoinY: (node) => node.y + node.height,
+          linkCompactXStart: (node) =>
+            node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
+          linkCompactYStart: (node) => node.y + node.height / 2,
+          compactLinkMidX: (node, state) =>
+            node.firstCompactNode.x +
+            node.firstCompactNode.flexCompactDim[0] / 4 +
+            state.compactMarginPair(node) / 4,
+          compactLinkMidY: (node) => node.firstCompactNode.y,
+          compactDimension: {
+            sizeColumn: (node) => node.width,
+            sizeRow: (node) => node.height,
+            reverse: (arr) => arr,
+          },
+          linkX: (node) => node.x,
+          linkY: (node) => node.y,
+          linkParentX: (node) => node.parent.x,
+          linkParentY: (node) => node.parent.y + node.parent.height,
+          buttonX: (node) => node.width / 2,
+          buttonY: (node) => node.height,
+          centerTransform: ({ root, rootMargin, centerY, scale, centerX }) =>
+            `translate(${centerX},${rootMargin}) scale(${scale})`,
+          nodeFlexSize: ({
+            height,
+            width,
+            siblingsMargin,
+            childrenMargin,
+            state,
+            node,
+            compactViewIndex,
+          }) => {
+            if (state.compact && node.flexCompactDim) {
+              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
+              return result;
+            }
+            return [width + siblingsMargin, height + childrenMargin];
+          },
+          zoomTransform: ({ centerX, scale }) =>
+            `translate(${centerX},0}) scale(${scale})`,
+          diagonal: this.diagonal.bind(this),
+          swap: (d) => {},
+          nodeUpdateTransform: ({ x, y, width, height }) =>
+            `translate(${x - width / 2},${y})`,
+        },
+        bottom: {
+          nodeLeftX: (node) => -node.width / 2,
+          nodeRightX: (node) => node.width / 2,
+          nodeTopY: (node) => -node.height,
+          nodeBottomY: (node) => 0,
+          nodeJoinX: (node) => node.x - node.width / 2,
+          nodeJoinY: (node) => node.y - node.height - node.height,
+          linkJoinX: (node) => node.x,
+          linkJoinY: (node) => node.y - node.height,
+          linkCompactXStart: (node) =>
+            node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
+          linkCompactYStart: (node) => node.y - node.height / 2,
+          compactLinkMidX: (node, state) =>
+            node.firstCompactNode.x +
+            node.firstCompactNode.flexCompactDim[0] / 4 +
+            state.compactMarginPair(node) / 4,
+          compactLinkMidY: (node) => node.firstCompactNode.y,
+          linkX: (node) => node.x,
+          linkY: (node) => node.y,
+          compactDimension: {
+            sizeColumn: (node) => node.width,
+            sizeRow: (node) => node.height,
+            reverse: (arr) => arr,
+          },
+          linkParentX: (node) => node.parent.x,
+          linkParentY: (node) => node.parent.y - node.parent.height,
+          buttonX: (node) => node.width / 2,
+          buttonY: (node) => 0,
+          centerTransform: ({
+            root,
+            rootMargin,
+            centerY,
+            scale,
+            centerX,
+            chartHeight,
+          }) =>
+            `translate(${centerX},${chartHeight - rootMargin}) scale(${scale})`,
+          nodeFlexSize: ({
+            height,
+            width,
+            siblingsMargin,
+            childrenMargin,
+            state,
+            node,
+          }) => {
+            if (state.compact && node.flexCompactDim) {
+              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
+              return result;
+            }
+            return [width + siblingsMargin, height + childrenMargin];
+          },
+          zoomTransform: ({ centerX, scale }) =>
+            `translate(${centerX},0}) scale(${scale})`,
+          diagonal: this.diagonal.bind(this),
+          swap: (d) => {
+            d.y = -d.y;
+          },
+          nodeUpdateTransform: ({ x, y, width, height }) =>
+            `translate(${x - width / 2},${y - height})`,
+        },
+        right: {
+          nodeLeftX: (node) => -node.width,
+          nodeRightX: (node) => 0,
+          nodeTopY: (node) => -node.height / 2,
+          nodeBottomY: (node) => node.height / 2,
+          nodeJoinX: (node) => node.x - node.width - node.width,
+          nodeJoinY: (node) => node.y - node.height / 2,
+          linkJoinX: (node) => node.x - node.width,
+          linkJoinY: (node) => node.y,
+          linkX: (node) => node.x,
+          linkY: (node) => node.y,
+          linkParentX: (node) => node.parent.x - node.parent.width,
+          linkParentY: (node) => node.parent.y,
+          buttonX: (node) => 0,
+          buttonY: (node) => node.height / 2,
+          linkCompactXStart: (node) => node.x - node.width / 2, //node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
+          linkCompactYStart: (node) =>
+            node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
+          compactLinkMidX: (node, state) => node.firstCompactNode.x, // node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
+          compactLinkMidY: (node, state) =>
+            node.firstCompactNode.y +
+            node.firstCompactNode.flexCompactDim[0] / 4 +
+            state.compactMarginPair(node) / 4,
+          centerTransform: ({
+            root,
+            rootMargin,
+            centerY,
+            scale,
+            centerX,
+            chartWidth,
+          }) =>
+            `translate(${chartWidth - rootMargin},${centerY}) scale(${scale})`,
+          nodeFlexSize: ({
+            height,
+            width,
+            siblingsMargin,
+            childrenMargin,
+            state,
+            node,
+          }) => {
+            if (state.compact && node.flexCompactDim) {
+              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
+              return result;
+            }
+            return [height + siblingsMargin, width + childrenMargin];
+          },
+          compactDimension: {
+            sizeColumn: (node) => node.height,
+            sizeRow: (node) => node.width,
+            reverse: (arr) => arr.slice().reverse(),
+          },
+          zoomTransform: ({ centerY, scale }) =>
+            `translate(${0},${centerY}) scale(${scale})`,
+          diagonal: this.hdiagonal.bind(this),
+          swap: (d) => {
+            const x = d.x;
+            d.x = -d.y;
+            d.y = x;
+          },
+          nodeUpdateTransform: ({ x, y, width, height }) =>
+            `translate(${x - width},${y - height / 2})`,
+        },
+      },
+      onExpandCollapseClick: (d, data) => {
+        console.log(d, data);
+      },
+      highlightedNodeId: '',
+      hoverCardContent: (d) => `<div>Tooltip</div>`,
+      tooltipData: {},
+      onZoom: (zoomScale, range) => {},
+    };
+
+    this.getChartState = () => attrs;
+
+    // Dynamically set getter and setter functions for Chart class
+    Object.keys(attrs).forEach((key) => {
+      //@ts-ignore
+      this[key] = function (_) {
+        if (!arguments.length) {
+          return attrs[key];
+        } else {
+          attrs[key] = _;
         }
-
-        // Loop over _children and recursively store descendants id (collapsed nodes)
-        if (_children) {
-            _children.forEach((d) => {
-                this.getNodeChildren(d, nodeStore);
-            });
+        return this;
+      };
+    });
+
+    this.initializeEnterExitUpdatePattern();
+  }
+
+  initializeEnterExitUpdatePattern() {
+    d3.selection.prototype.patternify = function (params) {
+      var container = this;
+      var selector = params.selector;
+      var elementTag = params.tag;
+      var data = params.data || [selector];
+      var id = params.id;
+
+      // Pattern in action
+      var selection = container.selectAll('.' + selector).data(data, (d, i) => {
+        if (typeof d === 'object') {
+          if (d.id) {
+            return d.id;
+          }
         }
-
-        // Return result
-        return nodeStore;
+        return i;
+      });
+      selection.exit().remove();
+      selection = selection.enter().append(elementTag).merge(selection);
+      selection.attr('class', selector);
+      selection.attr('id', id)
+      return selection;
+    };
+  }
+
+  // This method retrieves passed node's children IDs (including node)
+  getNodeChildren({ data, children, _children }, nodeStore) {
+    // Store current node ID
+    nodeStore.push(data);
+
+    // Loop over children and recursively store descendants id (expanded nodes)
+    if (children) {
+      children.forEach((d) => {
+        this.getNodeChildren(d, nodeStore);
+      });
     }
 
-    // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale
-    initialZoom(zoomLevel) {
-        const attrs = this.getChartState();
-        attrs.lastTransform.k = zoomLevel;
-        return this;
+    // Loop over _children and recursively store descendants id (collapsed nodes)
+    if (_children) {
+      _children.forEach((d) => {
+        this.getNodeChildren(d, nodeStore);
+      });
     }
 
-    render() {
-        //InnerFunctions which will update visuals
-        const attrs = this.getChartState();
-        if (!attrs.data || attrs.data.length == 0) {
-            console.log('ORG CHART - Data is empty')
-            return this;
-        }
-
-        //Drawing containers
-        const container = d3.select(attrs.container);
-        const containerRect = container.node().getBoundingClientRect();
-        if (containerRect.width > 0) attrs.svgWidth = containerRect.width;
-
-        //Calculated properties
-        const calc = {
-            id: `ID${Math.floor(Math.random() * 1000000)}`, // id for event handlings,
-            chartWidth: attrs.svgWidth,
-            chartHeight: attrs.svgHeight
-        };
-        attrs.calc = calc;
-
-        // Calculate max node depth (it's needed for layout heights calculation)
-        calc.centerX = calc.chartWidth / 2;
-        calc.centerY = calc.chartHeight / 2;
-
-        // ******************* BEHAVIORS  **********************
-        if (attrs.firstDraw) {
-            const behaviors = {
-                zoom: null
-            };
-
-            // Get zooming function
-            behaviors.zoom = d3.zoom().on("zoom", (event, d) => this.zoomed(event, d)).scaleExtent(attrs.scaleExtent)
-            attrs.zoomBehavior = behaviors.zoom;
-        }
-
-        //****************** ROOT node work ************************
-
-        attrs.flexTreeLayout = flextree({
-            nodeSize: node => {
-                const width = attrs.nodeWidth(node);;
-                const height = attrs.nodeHeight(node);
-                const siblingsMargin = attrs.siblingsMargin(node)
-                const childrenMargin = attrs.childrenMargin(node);
-                return attrs.layoutBindings[attrs.layout].nodeFlexSize({
-                    state: attrs,
-                    node: node,
-                    width,
-                    height,
-                    siblingsMargin,
-                    childrenMargin
-                });
-            }
-        })
-            .spacing((nodeA, nodeB) => nodeA.parent == nodeB.parent ? 0 : attrs.neightbourMargin(nodeA, nodeB));
-
-        this.setLayouts({ expandNodesFirst: false });
-
-        // *************************  DRAWING **************************
-        //Add svg
-        const svg = container
-            .patternify({
-                tag: "svg",
-                selector: "svg-chart-container"
-            })
-            .style('background-color', attrs.backgroundColor)
-            .attr("width", attrs.svgWidth)
-            .attr("height", attrs.svgHeight)
-            .attr("font-family", attrs.defaultFont)
-
-        if (attrs.firstDraw) {
-            svg.call(attrs.zoomBehavior)
-                .on("dblclick.zoom", null)
-                .attr("cursor", "move")
-        }
-
-        attrs.svg = svg;
-
-        //Add container g element
-        const chart = svg
-            .patternify({
-                tag: "g",
-                selector: "chart"
-            })
-
-        // Add one more container g element, for better positioning controls
-        attrs.centerG = chart
-            .patternify({
-                tag: "g",
-                selector: "center-group"
-            })
-
-        attrs.linksWrapper = attrs.centerG.patternify({
-            tag: "g",
-            selector: "links-wrapper"
-        })
-
-        attrs.nodesWrapper = attrs.centerG.patternify({
-            tag: "g",
-            selector: "nodes-wrapper"
-        })
-
-        attrs.connectionsWrapper = attrs.centerG.patternify({
-            tag: "g",
-            selector: "connections-wrapper"
-        })
+    // Return result
+    return nodeStore;
+  }
+
+  // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale
+  initialZoom(zoomLevel) {
+    const attrs = this.getChartState();
+    attrs.lastTransform.k = zoomLevel;
+    return this;
+  }
+
+  render() {
+    //InnerFunctions which will update visuals
+    const attrs = this.getChartState();
+    if (!attrs.data || attrs.data.length == 0) {
+      console.log('ORG CHART - Data is empty');
+      return this;
+    }
 
-        attrs.defsWrapper = svg.patternify({
-            tag: "g",
-            selector: "defs-wrapper"
+    //Drawing containers
+    const container = d3.select(attrs.container);
+    const containerRect = container.node().getBoundingClientRect();
+    if (containerRect.width > 0) attrs.svgWidth = containerRect.width;
+
+    //Calculated properties
+    const calc = {
+      id: `ID${Math.floor(Math.random() * 1000000)}`, // id for event handlings,
+      chartWidth: attrs.svgWidth,
+      chartHeight: attrs.svgHeight,
+    };
+    attrs.calc = calc;
+
+    // Calculate max node depth (it's needed for layout heights calculation)
+    calc.centerX = calc.chartWidth / 2;
+    calc.centerY = calc.chartHeight / 2;
+
+    // ******************* BEHAVIORS  **********************
+    if (attrs.firstDraw) {
+      const behaviors = {
+        zoom: null,
+      };
+
+      // Get zooming function
+      behaviors.zoom = d3
+        .zoom()
+        .on('zoom', (event, d) => {
+          this.zoomed(event, d);
+          this.getOutOfViewportNodes();
+          attrs.onZoom(event.transform.k, attrs.scaleExtent);
         })
+        .scaleExtent(attrs.scaleExtent);
+      attrs.zoomBehavior = behaviors.zoom;
+    }
 
-        if (attrs.firstDraw) {
-            attrs.centerG.attr("transform", () => {
-                return attrs.layoutBindings[attrs.layout].centerTransform({
-                    centerX: calc.centerX,
-                    centerY: calc.centerY,
-                    scale: attrs.lastTransform.k,
-                    rootMargin: attrs.rootMargin,
-                    root: attrs.root,
-                    chartHeight: calc.chartHeight,
-                    chartWidth: calc.chartWidth
-                })
-            });
-        }
-
-        attrs.chart = chart;
-
-        // Display tree contenrs
-        this.update(attrs.root);
-
-
-        //#########################################  UTIL FUNCS ##################################
-        // This function restyles foreign object elements ()
-
-        d3.select(window).on(`resize.${attrs.id}`, () => {
-            const containerRect = d3.select(attrs.container).node().getBoundingClientRect();
-            attrs.svg.attr('width', containerRect.width)
+    //****************** ROOT node work ************************
+
+    attrs.flexTreeLayout = flextree({
+      nodeSize: (node) => {
+        const width = attrs.nodeWidth(node);
+        const height = attrs.nodeHeight(node);
+        const siblingsMargin = attrs.siblingsMargin(node);
+        const childrenMargin = attrs.childrenMargin(node);
+        return attrs.layoutBindings[attrs.layout].nodeFlexSize({
+          state: attrs,
+          node: node,
+          width,
+          height,
+          siblingsMargin,
+          childrenMargin,
         });
-
-        if (attrs.firstDraw) {
-            attrs.firstDraw = false;
-        }
-
-        return this;
+      },
+    }).spacing((nodeA, nodeB) =>
+      nodeA.parent == nodeB.parent ? 0 : attrs.neightbourMargin(nodeA, nodeB),
+    );
+
+    this.setLayouts({ expandNodesFirst: false });
+
+    // *************************  DRAWING **************************
+    //Add svg
+    const svg = container
+      .patternify({
+        tag: 'svg',
+        selector: 'svg-chart-container',
+      })
+      .style('background-color', attrs.backgroundColor)
+      .attr('width', attrs.svgWidth)
+      .attr('height', attrs.svgHeight)
+      .attr('font-family', attrs.defaultFont);
+
+    if (attrs.firstDraw) {
+      svg
+        .call(attrs.zoomBehavior)
+        .on('dblclick.zoom', null)
+        .attr('cursor', 'move');
     }
 
-    // This function can be invoked via chart.addNode API, and it adds node in tree at runtime
-    addNode(obj) {
-        const attrs = this.getChartState();
-        const nodeFound = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) === attrs.nodeId(obj))[0];
-        const parentFound = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) === attrs.parentNodeId(obj))[0];
-        if (nodeFound) {
-            console.log(`ORG CHART - ADD - Node with id "${attrs.nodeId(obj)}" already exists in tree`)
-            return this;
-        }
-        if (!parentFound) {
-            console.log(`ORG CHART - ADD - Parent node with id "${attrs.parentNodeId(obj)}" not found in the tree`)
-            return this;
-        }
-        if (obj._centered && !obj._expanded) obj._expanded = true;
-        attrs.data.push(obj);
-
-        // Update state of nodes and redraw graph
-        this.updateNodesState();
-
-        return this;
+    attrs.svg = svg;
+
+    //Add container g element
+    const chart = svg
+      .patternify({
+        tag: 'g',
+        selector: 'chart',
+      })
+      .attr('id', 'svgChart')
+      .attr('class', 'chart relative');
+
+    // Add one more container g element, for better positioning controls
+    attrs.centerG = chart.patternify({
+      tag: 'g',
+      selector: 'center-group',
+    });
+
+    attrs.linksWrapper = attrs.centerG.patternify({
+      tag: 'g',
+      selector: 'links-wrapper',
+    });
+
+    attrs.nodesWrapper = attrs.centerG.patternify({
+      tag: 'g',
+      selector: 'nodes-wrapper',
+    });
+
+    attrs.connectionsWrapper = attrs.centerG.patternify({
+      tag: 'g',
+      selector: 'connections-wrapper',
+    });
+
+    attrs.defsWrapper = svg.patternify({
+      tag: 'g',
+      selector: 'defs-wrapper',
+    });
+
+    if (attrs.firstDraw) {
+      attrs.centerG.attr('transform', () => {
+        return attrs.layoutBindings[attrs.layout].centerTransform({
+          centerX: calc.centerX,
+          centerY: calc.centerY,
+          scale: attrs.lastTransform.k,
+          rootMargin: attrs.rootMargin,
+          root: attrs.root,
+          chartHeight: calc.chartHeight,
+          chartWidth: calc.chartWidth,
+        });
+      });
     }
 
-    // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime
-    removeNode(nodeId) {
-        const attrs = this.getChartState();
-        const node = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) == nodeId)[0];
-        if (!node) {
-            console.log(`ORG CHART - REMOVE - Node with id "${nodeId}" not found in the tree`);
-            return this;
-        }
-
-        // Remove all node childs
-        // Retrieve all children nodes ids (including current node itself)
-        node.descendants()
-            .forEach(d => d.data._filteredOut = true)
+    attrs.chart = chart;
 
-        const descendants = this.getNodeChildren(node, [], attrs.nodeId);
-        descendants.forEach(d => d._filtered = true)
+    // Display tree contenrs
+    this.update(attrs.root);
 
-        // Filter out retrieved nodes and reassign data
-        attrs.data = attrs.data.filter(d => !d._filtered);
+    //#########################################  UTIL FUNCS ##################################
+    // This function restyles foreign object elements ()
 
-        const updateNodesState = this.updateNodesState.bind(this);
-        // Update state of nodes and redraw graph
-        updateNodesState();
+    d3.select(window).on(`resize.${attrs.id}`, () => {
+      const containerRect = d3
+        .select(attrs.container)
+        .node()
+        .getBoundingClientRect();
+      attrs.svg.attr('width', containerRect.width);
+    });
 
-        return this;
+    if (attrs.firstDraw) {
+      attrs.firstDraw = false;
     }
 
-    groupBy(array, accessor, aggegator) {
-        const grouped = {}
-        array.forEach(item => {
-            const key = accessor(item)
-            if (!grouped[key]) {
-                grouped[key] = []
-            }
-            grouped[key].push(item)
-        })
-
-        Object.keys(grouped).forEach(key => {
-            grouped[key] = aggegator(grouped[key])
-        })
-        return Object.entries(grouped);
+    return this;
+  }
+
+  getOutOfViewportNodes() {
+    const attrs = this.getChartState();
+    // console.log(attrs.allNodes.forEach((node) => console.log(node)));
+  }
+
+  // This function can be invoked via chart.addNode API, and it adds node in tree at runtime
+  addNode(obj) {
+    const attrs = this.getChartState();
+    const nodeFound = attrs.allNodes.filter(
+      ({ data }) => attrs.nodeId(data) === attrs.nodeId(obj),
+    )[0];
+    const parentFound = attrs.allNodes.filter(
+      ({ data }) => attrs.nodeId(data) === attrs.parentNodeId(obj),
+    )[0];
+    if (nodeFound) {
+      console.log(
+        `ORG CHART - ADD - Node with id "${attrs.nodeId(
+          obj,
+        )}" already exists in tree`,
+      );
+      return this;
     }
-    calculateCompactFlexDimensions(root) {
-        const attrs = this.getChartState();
-        root.eachBefore(node => {
-            node.firstCompact = null;
-            node.compactEven = null;
-            node.flexCompactDim = null;
-            node.firstCompactNode = null;
-        })
-        root.eachBefore(node => {
-            if (node.children && node.children.length > 1) {
-                const compactChildren = node.children.filter(d => !d.children);
-                if (compactChildren.length < 2) return;
-                compactChildren.forEach((child, i) => {
-                    if (!i) child.firstCompact = true;
-                    if (i % 2) child.compactEven = false;
-                    else child.compactEven = true;
-                    child.row = Math.floor(i / 2);
-                })
-                const evenMaxColumnDimension = d3.max(compactChildren.filter(d => d.compactEven), attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn);
-                const oddMaxColumnDimension = d3.max(compactChildren.filter(d => !d.compactEven), attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn);
-                const columnSize = Math.max(evenMaxColumnDimension, oddMaxColumnDimension) * 2;
-                const rowsMapNew = this.groupBy(compactChildren, d => d.row, reducedGroup => d3.max(reducedGroup, d => attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d) + attrs.compactMarginBetween(d)));
-                const rowSize = d3.sum(rowsMapNew.map(v => v[1]))
-                compactChildren.forEach(node => {
-                    node.firstCompactNode = compactChildren[0];
-                    if (node.firstCompact) {
-                        node.flexCompactDim = [
-                            columnSize + attrs.compactMarginPair(node),
-                            rowSize - attrs.compactMarginBetween(node)
-                        ];
-                    } else {
-                        node.flexCompactDim = [0, 0];
-                    }
-                })
-                node.flexCompactDim = null;
-            }
-        })
+    if (!parentFound) {
+      console.log(
+        `ORG CHART - ADD - Parent node with id "${attrs.parentNodeId(
+          obj,
+        )}" not found in the tree`,
+      );
+      return this;
     }
-
-    calculateCompactFlexPositions(root) {
-        const attrs = this.getChartState();
-        root.eachBefore(node => {
-            if (node.children) {
-                const compactChildren = node.children.filter(d => d.flexCompactDim);
-                const fch = compactChildren[0];
-                if (!fch) return;
-                compactChildren.forEach((child, i, arr) => {
-                    if (i == 0) fch.x -= fch.flexCompactDim[0] / 2;
-                    if (i & i % 2 - 1) child.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(child) / 4;
-                    else if (i) child.x = fch.x + fch.flexCompactDim[0] * 0.75 + attrs.compactMarginPair(child) / 4;
-                })
-                const centerX = fch.x + fch.flexCompactDim[0] * 0.5;
-                fch.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(fch) / 4;
-                const offsetX = node.x - centerX;
-                if (Math.abs(offsetX) < 10) {
-                    compactChildren.forEach(d => d.x += offsetX);
-                }
-
-                const rowsMapNew = this.groupBy(compactChildren, d => d.row, reducedGroup => d3.max(reducedGroup, d => attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d)));
-                const cumSum = d3.cumsum(rowsMapNew.map(d => d[1] + attrs.compactMarginBetween(d)));
-                compactChildren
-                    .forEach((node, i) => {
-                        if (node.row) {
-                            node.y = fch.y + cumSum[node.row - 1]
-                        } else {
-                            node.y = fch.y;
-                        }
-                    })
-
-            }
-        })
+    if (obj._centered && !obj._expanded) obj._expanded = true;
+    attrs.data.push(obj);
+
+    // Update state of nodes and redraw graph
+    this.updateNodesState();
+
+    return this;
+  }
+
+  // This function can be invoked via chart.addNodes API, and it adds node in tree at runtime
+  addNodes(nodes){
+    const attrs = this.getChartState();
+    nodes.forEach((node) => {
+      const nodeFound = attrs.allNodes.filter(
+        ({ data }) => attrs.nodeId(data) === attrs.nodeId(node),
+      )[0];
+      if(nodeFound){
+        return;
+      }else{
+        if (node._centered && !node._expanded) node._expanded = true;
+        attrs.data.push(node);
+      }
+    })
+    // Update state of nodes and redraw graph
+    this.updateNodesState();
+  }
+
+  // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime
+  removeNode(nodeId) {
+    const attrs = this.getChartState();
+    const node = attrs.allNodes.filter(
+      ({ data }) => attrs.nodeId(data) == nodeId,
+    )[0];
+    if (!node) {
+      console.log(
+        `ORG CHART - REMOVE - Node with id "${nodeId}" not found in the tree`,
+      );
+      return this;
     }
 
-    // This function basically redraws visible graph, based on nodes state
-    update({ x0, y0, x = 0, y = 0, width, height }) {
-        const attrs = this.getChartState();
-        const calc = attrs.calc;
-
-
-        if (attrs.compact) {
-            this.calculateCompactFlexDimensions(attrs.root);
+    // Remove all node childs
+    // Retrieve all children nodes ids (including current node itself)
+    node.descendants().forEach((d) => (d.data._filteredOut = true));
+
+    const descendants = this.getNodeChildren(node, [], attrs.nodeId);
+    descendants.forEach((d) => (d._filtered = true));
+
+    // Filter out retrieved nodes and reassign data
+    attrs.data = attrs.data.filter((d) => !d._filtered);
+
+    const updateNodesState = this.updateNodesState.bind(this);
+    // Update state of nodes and redraw graph
+    updateNodesState();
+
+    return this;
+  }
+
+  groupBy(array, accessor, aggegator) {
+    const grouped = {};
+    array.forEach((item) => {
+      const key = accessor(item);
+      if (!grouped[key]) {
+        grouped[key] = [];
+      }
+      grouped[key].push(item);
+    });
+
+    Object.keys(grouped).forEach((key) => {
+      grouped[key] = aggegator(grouped[key]);
+    });
+    return Object.entries(grouped);
+  }
+  calculateCompactFlexDimensions(root) {
+    const attrs = this.getChartState();
+    root.eachBefore((node) => {
+      node.firstCompact = null;
+      node.compactEven = null;
+      node.flexCompactDim = null;
+      node.firstCompactNode = null;
+    });
+    root.eachBefore((node) => {
+      if (node.children && node.children.length > 1) {
+        const compactChildren = node.children.filter((d) => !d.children);
+        if (compactChildren.length < 2) return;
+        compactChildren.forEach((child, i) => {
+          if (!i) child.firstCompact = true;
+          if (i % 2) child.compactEven = false;
+          else child.compactEven = true;
+          child.row = Math.floor(i / 2);
+        });
+        const evenMaxColumnDimension = d3.max(
+          compactChildren.filter((d) => d.compactEven),
+          attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn,
+        );
+        const oddMaxColumnDimension = d3.max(
+          compactChildren.filter((d) => !d.compactEven),
+          attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn,
+        );
+        const columnSize =
+          Math.max(evenMaxColumnDimension, oddMaxColumnDimension) * 2;
+        const rowsMapNew = this.groupBy(
+          compactChildren,
+          (d) => d.row,
+          (reducedGroup) =>
+            d3.max(
+              reducedGroup,
+              (d) =>
+                attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d) +
+                attrs.compactMarginBetween(d),
+            ),
+        );
+        const rowSize = d3.sum(rowsMapNew.map((v) => v[1]));
+        compactChildren.forEach((node) => {
+          node.firstCompactNode = compactChildren[0];
+          if (node.firstCompact) {
+            node.flexCompactDim = [
+              columnSize + attrs.compactMarginPair(node),
+              rowSize - attrs.compactMarginBetween(node),
+            ];
+          } else {
+            node.flexCompactDim = [0, 0];
+          }
+        });
+        node.flexCompactDim = null;
+      }
+    });
+  }
+
+  calculateCompactFlexPositions(root) {
+    const attrs = this.getChartState();
+    root.eachBefore((node) => {
+      if (node.children) {
+        const compactChildren = node.children.filter((d) => d.flexCompactDim);
+        const fch = compactChildren[0];
+        if (!fch) return;
+        compactChildren.forEach((child, i, arr) => {
+          if (i == 0) fch.x -= fch.flexCompactDim[0] / 2;
+          if (i & ((i % 2) - 1))
+            child.x =
+              fch.x +
+              fch.flexCompactDim[0] * 0.25 -
+              attrs.compactMarginPair(child) / 4;
+          else if (i)
+            child.x =
+              fch.x +
+              fch.flexCompactDim[0] * 0.75 +
+              attrs.compactMarginPair(child) / 4;
+        });
+        const centerX = fch.x + fch.flexCompactDim[0] * 0.5;
+        fch.x =
+          fch.x +
+          fch.flexCompactDim[0] * 0.25 -
+          attrs.compactMarginPair(fch) / 4;
+        const offsetX = node.x - centerX;
+        if (Math.abs(offsetX) < 10) {
+          compactChildren.forEach((d) => (d.x += offsetX));
         }
 
-        //  Assigns the x and y position for the nodes
-        const treeData = attrs.flexTreeLayout(attrs.root);
+        const rowsMapNew = this.groupBy(
+          compactChildren,
+          (d) => d.row,
+          (reducedGroup) =>
+            d3.max(reducedGroup, (d) =>
+              attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d),
+            ),
+        );
+        const cumSum = d3.cumsum(
+          rowsMapNew.map((d) => d[1] + attrs.compactMarginBetween(d)),
+        );
+        compactChildren.forEach((node, i) => {
+          if (node.row) {
+            node.y = fch.y + cumSum[node.row - 1];
+          } else {
+            node.y = fch.y;
+          }
+        });
+      }
+    });
+  }
 
-        // Reassigns the x and y position for the based on the compact layout
-        if (attrs.compact) {
-            this.calculateCompactFlexPositions(attrs.root);
-        }
+  // This function basically redraws visible graph, based on nodes state
+  update({ x0, y0, x = 0, y = 0, width, height }) {
+    const attrs = this.getChartState();
+    const calc = attrs.calc;
 
-        const nodes = treeData.descendants();
+    if (attrs.compact) {
+      this.calculateCompactFlexDimensions(attrs.root);
+    }
 
-        // console.table(nodes.map(d => ({ x: d.x, y: d.y, width: d.width, height: d.height, flexCompactDim: d.flexCompactDim + "" })))
+    //  Assigns the x and y position for the nodes
+    const treeData = attrs.flexTreeLayout(attrs.root);
 
-        // Get all links
-        const links = treeData.descendants().slice(1);
-        nodes.forEach(attrs.layoutBindings[attrs.layout].swap)
+    // Reassigns the x and y position for the based on the compact layout
+    if (attrs.compact) {
+      this.calculateCompactFlexPositions(attrs.root);
+    }
 
-        // Connections
-        const connections = attrs.connections;
-        const allNodesMap = {};
-        attrs.allNodes.forEach(d => allNodesMap[attrs.nodeId(d.data)] = d);
+    const nodes = treeData.descendants();
+
+    // console.table(nodes.map(d => ({ x: d.x, y: d.y, width: d.width, height: d.height, flexCompactDim: d.flexCompactDim + "" })))
+
+    // Get all links
+    const links = treeData.descendants().slice(1);
+    nodes.forEach(attrs.layoutBindings[attrs.layout].swap);
+
+    // Connections
+    const connections = attrs.connections;
+    const allNodesMap = {};
+    attrs.allNodes.forEach((d) => (allNodesMap[attrs.nodeId(d.data)] = d));
+
+    const visibleNodesMap = {};
+    nodes.forEach((d) => (visibleNodesMap[attrs.nodeId(d.data)] = d));
+
+    connections.forEach((connection) => {
+      const source = allNodesMap[connection.from];
+      const target = allNodesMap[connection.to];
+      connection._source = source;
+      connection._target = target;
+    });
+    const visibleConnections = connections.filter(
+      (d) => visibleNodesMap[d.from] && visibleNodesMap[d.to],
+    );
+    const defsString = attrs.defs.bind(this)(attrs, visibleConnections);
+    const existingString = attrs.defsWrapper.html();
+    if (defsString !== existingString) {
+      attrs.defsWrapper.html(defsString);
+    }
 
-        const visibleNodesMap = {}
-        nodes.forEach(d => visibleNodesMap[attrs.nodeId(d.data)] = d);
+    // --------------------------  LINKS ----------------------
+    // Get links selection
+    const linkSelection = attrs.linksWrapper
+      .selectAll('path.link')
+      .data(links, (d) => attrs.nodeId(d.data));
+
+    // Enter any new links at the parent's previous position.
+    const linkEnter = linkSelection
+      .enter()
+      .insert('path', 'g')
+      .attr('class', 'link')
+      .attr('d', (d) => {
+        const xo = attrs.layoutBindings[attrs.layout].linkJoinX({
+          x: x0,
+          y: y0,
+          width,
+          height,
+        });
+        const yo = attrs.layoutBindings[attrs.layout].linkJoinY({
+          x: x0,
+          y: y0,
+          width,
+          height,
+        });
+        const o = { x: xo, y: yo };
+        return attrs.layoutBindings[attrs.layout].diagonal(o, o, o);
+      });
+
+    // Get links update selection
+    const linkUpdate = linkEnter.merge(linkSelection);
+
+    // Styling links
+    linkUpdate.attr('fill', 'none');
+
+    // Allow external modifications
+    linkUpdate.each(attrs.linkUpdate);
+
+    // Transition back to the parent element position
+    linkUpdate
+      .transition()
+      .duration(attrs.duration)
+      .attr('d', (d) => {
+        const n =
+          attrs.compact && d.flexCompactDim
+            ? {
+                x: attrs.layoutBindings[attrs.layout].compactLinkMidX(d, attrs),
+                y: attrs.layoutBindings[attrs.layout].compactLinkMidY(d, attrs),
+              }
+            : {
+                x: attrs.layoutBindings[attrs.layout].linkX(d),
+                y: attrs.layoutBindings[attrs.layout].linkY(d),
+              };
+
+        const p = {
+          x: attrs.layoutBindings[attrs.layout].linkParentX(d),
+          y: attrs.layoutBindings[attrs.layout].linkParentY(d),
+        };
 
-        connections.forEach(connection => {
-            const source = allNodesMap[connection.from];
-            const target = allNodesMap[connection.to];
-            connection._source = source;
-            connection._target = target;
-        })
-        const visibleConnections = connections.filter(d => visibleNodesMap[d.from] && visibleNodesMap[d.to]);
-        const defsString = attrs.defs.bind(this)(attrs, visibleConnections);
-        const existingString = attrs.defsWrapper.html();
-        if (defsString !== existingString) {
-            attrs.defsWrapper.html(defsString)
+        const m =
+          attrs.compact && d.flexCompactDim
+            ? {
+                x: attrs.layoutBindings[attrs.layout].linkCompactXStart(d),
+                y: attrs.layoutBindings[attrs.layout].linkCompactYStart(d),
+              }
+            : n;
+        return attrs.layoutBindings[attrs.layout].diagonal(n, p, m);
+      });
+
+    // Remove any  links which is exiting after animation
+    const linkExit = linkSelection
+      .exit()
+      .transition()
+      .duration(attrs.duration)
+      .attr('d', (d) => {
+        const xo = attrs.layoutBindings[attrs.layout].linkJoinX({
+          x,
+          y,
+          width,
+          height,
+        });
+        const yo = attrs.layoutBindings[attrs.layout].linkJoinY({
+          x,
+          y,
+          width,
+          height,
+        });
+        const o = { x: xo, y: yo };
+        return attrs.layoutBindings[attrs.layout].diagonal(o, o);
+      })
+      .remove();
+
+    // --------------------------  CONNECTIONS ----------------------
+
+    const connectionsSel = attrs.connectionsWrapper
+      .selectAll('path.connection')
+      .data(visibleConnections);
+
+    // Enter any new connections at the parent's previous position.
+    const connEnter = connectionsSel
+      .enter()
+      .insert('path', 'g')
+      .attr('class', 'connection')
+      .attr('d', (d) => {
+        const xo = attrs.layoutBindings[attrs.layout].linkJoinX({
+          x: x0,
+          y: y0,
+          width,
+          height,
+        });
+        const yo = attrs.layoutBindings[attrs.layout].linkJoinY({
+          x: x0,
+          y: y0,
+          width,
+          height,
+        });
+        const o = { x: xo, y: yo };
+        return attrs.layoutBindings[attrs.layout].diagonal(o, o);
+      });
+
+    // Get connections update selection
+    const connUpdate = connEnter.merge(connectionsSel);
+
+    // Styling connections
+    connUpdate.attr('fill', 'none');
+
+    // Transition back to the parent element position
+    connUpdate
+      .transition()
+      .duration(attrs.duration)
+      .attr('d', (d) => {
+        const xs = attrs.layoutBindings[attrs.layout].linkX({
+          x: d._source.x,
+          y: d._source.y,
+          width: d._source.width,
+          height: d._source.height,
+        });
+        const ys = attrs.layoutBindings[attrs.layout].linkY({
+          x: d._source.x,
+          y: d._source.y,
+          width: d._source.width,
+          height: d._source.height,
+        });
+        const xt = attrs.layoutBindings[attrs.layout].linkJoinX({
+          x: d._target.x,
+          y: d._target.y,
+          width: d._target.width,
+          height: d._target.height,
+        });
+        const yt = attrs.layoutBindings[attrs.layout].linkJoinY({
+          x: d._target.x,
+          y: d._target.y,
+          width: d._target.width,
+          height: d._target.height,
+        });
+        return attrs.linkGroupArc({
+          source: { x: xs, y: ys },
+          target: { x: xt, y: yt },
+        });
+      });
+
+    // Allow external modifications
+    connUpdate.each(attrs.connectionsUpdate);
+
+    // Remove any  links which is exiting after animation
+    const connExit = connectionsSel
+      .exit()
+      .transition()
+      .duration(attrs.duration)
+      .attr('opacity', 0)
+      .remove();
+
+    // --------------------------  NODES ----------------------
+    // Get nodes selection
+    const nodesSelection = attrs.nodesWrapper
+      .selectAll('g.node')
+      .data(nodes, ({ data }) => attrs.nodeId(data));
+
+    // Enter any new nodes at the parent's previous position.
+    const nodeEnter = nodesSelection
+      .enter()
+      .append('g')
+      .attr('class', 'node')
+      .attr('transform', (d) => {
+        if (d == attrs.root) return `translate(${x0},${y0})`;
+        const xj = attrs.layoutBindings[attrs.layout].nodeJoinX({
+          x: x0,
+          y: y0,
+          width,
+          height,
+        });
+        const yj = attrs.layoutBindings[attrs.layout].nodeJoinY({
+          x: x0,
+          y: y0,
+          width,
+          height,
+        });
+        return `translate(${xj},${yj})`;
+      })
+      .attr('cursor', 'pointer')
+      .on('click', (event, { data }) => {
+        if (
+          [...event.srcElement.classList].includes('node-button-foreign-object')
+        ) {
+          return;
         }
-
-        // --------------------------  LINKS ----------------------
-        // Get links selection
-        const linkSelection = attrs.linksWrapper
-            .selectAll("path.link")
-            .data(links, (d) => attrs.nodeId(d.data));
-
-        // Enter any new links at the parent's previous position.
-        const linkEnter = linkSelection
-            .enter()
-            .insert("path", "g")
-            .attr("class", "link")
-            .attr("d", (d) => {
-                const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
-                const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
-                const o = { x: xo, y: yo };
-                return attrs.layoutBindings[attrs.layout].diagonal(o, o, o);
-            });
-
-        // Get links update selection
-        const linkUpdate = linkEnter.merge(linkSelection);
-
-        // Styling links
-        linkUpdate
-            .attr("fill", "none")
-
-        // Allow external modifications
-        linkUpdate.each(attrs.linkUpdate);
-
-        // Transition back to the parent element position
-        linkUpdate
-            .transition()
-            .duration(attrs.duration)
-            .attr("d", (d) => {
-                const n = attrs.compact && d.flexCompactDim ?
-                    {
-                        x: attrs.layoutBindings[attrs.layout].compactLinkMidX(d, attrs),
-                        y: attrs.layoutBindings[attrs.layout].compactLinkMidY(d, attrs)
-                    } :
-                    {
-                        x: attrs.layoutBindings[attrs.layout].linkX(d),
-                        y: attrs.layoutBindings[attrs.layout].linkY(d)
-                    };
-
-                const p = {
-                    x: attrs.layoutBindings[attrs.layout].linkParentX(d),
-                    y: attrs.layoutBindings[attrs.layout].linkParentY(d),
-                };
-
-                const m = attrs.compact && d.flexCompactDim ? {
-                    x: attrs.layoutBindings[attrs.layout].linkCompactXStart(d),
-                    y: attrs.layoutBindings[attrs.layout].linkCompactYStart(d),
-                } : n;
-                return attrs.layoutBindings[attrs.layout].diagonal(n, p, m);
-            });
-
-        // Remove any  links which is exiting after animation
-        const linkExit = linkSelection
-            .exit()
-            .transition()
-            .duration(attrs.duration)
-            .attr("d", (d) => {
-                const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x, y, width, height });
-                const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x, y, width, height });
-                const o = { x: xo, y: yo };
-                return attrs.layoutBindings[attrs.layout].diagonal(o, o);
-            })
-            .remove();
-
-
-        // --------------------------  CONNECTIONS ----------------------
-
-        const connectionsSel = attrs.connectionsWrapper
-            .selectAll("path.connection")
-            .data(visibleConnections)
-
-        // Enter any new connections at the parent's previous position.
-        const connEnter = connectionsSel
-            .enter()
-            .insert("path", "g")
-            .attr("class", "connection")
-            .attr("d", (d) => {
-                const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
-                const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
-                const o = { x: xo, y: yo };
-                return attrs.layoutBindings[attrs.layout].diagonal(o, o);
-            });
-
-
-        // Get connections update selection
-        const connUpdate = connEnter.merge(connectionsSel);
-
-        // Styling connections
-        connUpdate.attr("fill", "none")
-
-        // Transition back to the parent element position
-        connUpdate
-            .transition()
-            .duration(attrs.duration)
-            .attr('d', (d) => {
-                const xs = attrs.layoutBindings[attrs.layout].linkX({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
-                const ys = attrs.layoutBindings[attrs.layout].linkY({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
-                const xt = attrs.layoutBindings[attrs.layout].linkJoinX({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
-                const yt = attrs.layoutBindings[attrs.layout].linkJoinY({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
-                return attrs.linkGroupArc({ source: { x: xs, y: ys }, target: { x: xt, y: yt } })
-            })
-
-        // Allow external modifications
-        connUpdate.each(attrs.connectionsUpdate);
-
-        // Remove any  links which is exiting after animation
-        const connExit = connectionsSel
-            .exit()
-            .transition()
-            .duration(attrs.duration)
-            .attr('opacity', 0)
-            .remove();
-
-        // --------------------------  NODES ----------------------
-        // Get nodes selection
-        const nodesSelection = attrs.nodesWrapper
-            .selectAll("g.node")
-            .data(nodes, ({ data }) => attrs.nodeId(data));
-
-        // Enter any new nodes at the parent's previous position.
-        const nodeEnter = nodesSelection
-            .enter()
-            .append("g")
-            .attr("class", "node")
-            .attr("transform", (d) => {
-                if (d == attrs.root) return `translate(${x0},${y0})`
-                const xj = attrs.layoutBindings[attrs.layout].nodeJoinX({ x: x0, y: y0, width, height });
-                const yj = attrs.layoutBindings[attrs.layout].nodeJoinY({ x: x0, y: y0, width, height });
-                return `translate(${xj},${yj})`
-            })
-            .attr("cursor", "pointer")
-            .on("click", (event, { data }) => {
-                if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
-                    return;
-                }
-                attrs.onNodeClick(attrs.nodeId(data));
-            });
-
-        // Add background rectangle for the nodes
-        nodeEnter
-            .patternify({
-                tag: "rect",
-                selector: "node-rect",
-                data: (d) => [d]
-            })
-
-        // Node update styles
-        const nodeUpdate = nodeEnter
-            .merge(nodesSelection)
-            .style("font", "12px sans-serif");
-
-        // Add foreignObject element inside rectangle
-        const fo = nodeUpdate.patternify({
-            tag: "foreignObject",
-            selector: "node-foreign-object",
-            data: (d) => [d]
-        })
-            .style('overflow', 'visible')
-
-        // Add foreign object
-        fo.patternify({
-            tag: "xhtml:div",
-            selector: "node-foreign-object-div",
-            data: (d) => [d]
-        })
-
-        this.restyleForeignObjectElements();
-
-        // Add Node button circle's group (expand-collapse button)
-        const nodeButtonGroups = nodeEnter
-            .patternify({
-                tag: "g",
-                selector: "node-button-g",
-                data: (d) => [d]
-            })
-            .on("click", (event, d) => this.onButtonClick(event, d))
-            .on("keydown", (event, d) => {
-                if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
-                    this.onButtonClick(event, d)
-                }
+        attrs.onNodeClick(data);
+      })
+      .on('mouseenter', (e, {data}) => {
+        if(!attrs.tooltipData[data.id]){
+          if(data.id !== 'root'){
+            apiService.get(`/users/${data.id}`).then((reponse) => {
+              try{
+                attrs.tooltipData[data.id] = reponse.data.result.data
+                div.innerHTML = attrs.hoverCardContent.bind(this)({nodeData: data, userData: attrs.tooltipData[data.id]})
+              }catch(e){}
             });
-
-        nodeButtonGroups.patternify({
-            tag: 'rect',
-            selector: 'node-button-rect',
-            data: (d) => [d]
-        })
-            .attr('opacity', 0)
-            .attr('pointer-events', 'all')
-            .attr('width', 40)
-            .attr('height', 40)
-            .attr('x', -20)
-            .attr('y', -20)
-
-        // Add expand collapse button content
-        const nodeFo = nodeButtonGroups
-            .patternify({
-                tag: "foreignObject",
-                selector: "node-button-foreign-object",
-                data: (d) => [d]
-            })
-            .attr('width', 40)
-            .attr('height', 40)
-            .attr('x', -20)
-            .attr('y', -20)
-            .style('overflow', 'visible')
-            .patternify({
-                tag: "xhtml:div",
-                selector: "node-button-div",
-                data: (d) => [d]
-            })
-            .style('pointer-events', 'none')
-            .style('display', 'flex')
-            .style('width', '100%')
-            .style('height', '100%')
-
-
-
-        // Transition to the proper position for the node
-        nodeUpdate
-            .transition()
-            .attr("opacity", 0)
-            .duration(attrs.duration)
-            .attr("transform", ({ x, y, width, height }) => {
-                return attrs.layoutBindings[attrs.layout].nodeUpdateTransform({ x, y, width, height });
-
-            })
-            .attr("opacity", 1);
-
-        // Style node rectangles
-        nodeUpdate
-            .select(".node-rect")
-            .attr("width", ({ width }) => width)
-            .attr("height", ({ height }) => height)
-            .attr("x", ({ width }) => 0)
-            .attr("y", ({ height }) => 0)
-            .attr("cursor", "pointer")
-            .attr('rx', 3)
-            .attr("fill", attrs.nodeDefaultBackground)
-
-        // Move node button group to the desired position
-        nodeUpdate
-            .select(".node-button-g")
-            .attr("transform", ({ data, width, height }) => {
-                const x = attrs.layoutBindings[attrs.layout].buttonX({ width, height });
-                const y = attrs.layoutBindings[attrs.layout].buttonY({ width, height });
-                return `translate(${x},${y})`
-            })
-            .attr("display", ({ data }) => {
-                return data._directSubordinates > 0 ? null : 'none';
-            })
-            .attr("opacity", ({ children, _children }) => {
-                if (children || _children) {
-                    return 1;
-                }
-                return 0;
-            });
-
-        // Restyle node button circle
-        nodeUpdate
-            .select(".node-button-foreign-object .node-button-div")
-            .html((node) => {
-                return attrs.buttonContent({ node, state: attrs })
-            })
-
-        // Restyle button texts
-        nodeUpdate
-            .select(".node-button-text")
-            .attr("text-anchor", "middle")
-            .attr("alignment-baseline", "middle")
-            .attr("fill", attrs.defaultTextFill)
-            .attr("font-size", ({ children }) => {
-                if (children) return 40;
-                return 26;
-            })
-            .text(({ children }) => {
-                if (children) return "-";
-                return "+";
-            })
-            .attr("y", this.isEdge() ? 10 : 0);
-
-        nodeUpdate.each(attrs.nodeUpdate)
-
-        // Remove any exiting nodes after transition
-        const nodeExitTransition = nodesSelection
-            .exit()
-            .attr("opacity", 1)
-            .transition()
-            .duration(attrs.duration)
-            .attr("transform", (d) => {
-                const ex = attrs.layoutBindings[attrs.layout].nodeJoinX({ x, y, width, height });
-                const ey = attrs.layoutBindings[attrs.layout].nodeJoinY({ x, y, width, height });
-                return `translate(${ex},${ey})`
-            })
-            .on("end", function () {
-                d3.select(this).remove();
-            })
-            .attr("opacity", 0);
-
-        // Store the old positions for transition.
-        nodes.forEach((d) => {
-            d.x0 = d.x;
-            d.y0 = d.y;
-        });
-
-        // CHECK FOR CENTERING
-        const centeredNode = attrs.allNodes.filter(d => d.data._centered)[0]
-        if (centeredNode) {
-            const centeredNodes = centeredNode.data._centeredWithDescendants ? centeredNode.descendants().filter((d, i) => i < 7) : [centeredNode]
-            centeredNode.data._centeredWithDescendants = null;
-            centeredNode.data._centered = null;
-            this.fit({
-                animate: true,
-                scale: false,
-                nodes: centeredNodes
-            })
+          }
         }
-
+      })
+      .on('mouseover', (e, { data }) => {
+        const div = document.createElement('div');
+          div.setAttribute('id', `${data.id}-tooltip`);
+          div.setAttribute('class', 'absolute org-chart-tooltip');
+          let attrs = this.getChartState();
+          if(attrs.tooltipData[data.id]){
+            div.innerHTML = attrs.hoverCardContent.bind(this)({nodeData: data, userData: attrs.tooltipData[data.id]})
+          }else{
+            if(data.id !== 'root'){
+              div.innerHTML = "<div>Loading...</div>"
+            }
+          }
+          document.getElementById('org-chart-container').appendChild(div);
+          div.setAttribute(
+            'style',
+            `top: ${
+              e.pageY -
+              document
+                .getElementById('org-chart-container')
+                .getBoundingClientRect().y +
+              40
+            }px; left:${
+              e.pageX -
+              document
+                .getElementById('org-chart-container')
+                .getBoundingClientRect().x -
+              div.getBoundingClientRect().width / 2
+            }px`,
+          );
+      })
+      .on('mousemove', (e, { data }) => {
+        try {
+          document
+            .getElementById(`${data.id}-tooltip`)
+            .setAttribute(
+              'style',
+              `top: ${
+                e.pageY -
+                document
+                  .getElementById('org-chart-container')
+                  .getBoundingClientRect().y +
+                40
+              }px; left:${
+                e.pageX -
+                document
+                  .getElementById('org-chart-container')
+                  .getBoundingClientRect().x -
+                document
+                  .getElementById(`${data.id}-tooltip`)
+                  .getBoundingClientRect().width /
+                  2
+              }px`,
+            );
+        } catch (e) {}
+      })
+      .on('mouseout', function (d, { data }) {
+        document
+            .querySelectorAll('.org-chart-tooltip')
+            .forEach((el) => el.remove());
+      });
+
+    // Add background rectangle for the nodes
+    nodeEnter.patternify({
+      tag: 'rect',
+      selector: 'node-rect',
+      data: (d) => [d],
+    });
+
+    // Node update styles
+    const nodeUpdate = nodeEnter
+      .merge(nodesSelection)
+      .style('font', '12px sans-serif');
+
+    // Add foreignObject element inside rectangle
+    const fo = nodeUpdate
+      .patternify({
+        tag: 'foreignObject',
+        selector: 'node-foreign-object',
+        data: (d) => [d],
+      })
+      .style('overflow', 'visible');
+
+    // Add foreign object
+    fo.patternify({
+      tag: 'xhtml:div',
+      selector: 'node-foreign-object-div',
+      data: (d) => [d],
+    });
+
+    this.restyleForeignObjectElements();
+
+    // Add Node button circle's group (expand-collapse button)
+    const nodeButtonGroups = nodeEnter
+      .patternify({
+        tag: 'g',
+        selector: 'node-button-g',
+        data: (d) => [d],
+        id: (d) => `expand-btn-${d.data.id}`,
+      })
+      .on('click', (event, d) => this.onButtonClick(event, d))
+      .on('keydown', (event, d) => {
+        if (
+          event.key === 'Enter' ||
+          event.key === ' ' ||
+          event.key === 'Spacebar'
+        ) {
+          this.onButtonClick(event, d);
+        }
+      });
+
+    nodeButtonGroups
+      .patternify({
+        tag: 'rect',
+        selector: 'node-button-rect',
+        data: (d) => [d],
+      })
+      .attr('opacity', 0)
+      .attr('pointer-events', 'all')
+      .attr('width', 130)
+      .attr('height', 40)
+      .attr('x', -20)
+      .attr('y', -20)
+      .attr('style', "width:130px !important;");
+
+    // Add expand collapse button content
+    const nodeFo = nodeButtonGroups
+      .patternify({
+        tag: 'foreignObject',
+        selector: 'node-button-foreign-object',
+        data: (d) => [d],
+      })
+      .attr('width', 130)
+      .attr('height', 40)
+      .attr('x', -20)
+      .attr('y', -20)
+      .style('overflow', 'visible')
+      .patternify({
+        tag: 'xhtml:div',
+        selector: 'node-button-div',
+        data: (d) => [d],
+      })
+      .style('pointer-events', 'none')
+      .style('display', 'flex')
+      .style('width', '100%')
+      .style('height', '100%')
+      .attr('style', "width:130px !important;");
+
+    // Transition to the proper position for the node
+    nodeUpdate
+      .transition()
+      .attr('opacity', 0)
+      .duration(attrs.duration)
+      .attr('transform', ({ x, y, width, height }) => {
+        return attrs.layoutBindings[attrs.layout].nodeUpdateTransform({
+          x,
+          y,
+          width,
+          height,
+        });
+      })
+      .attr('opacity', 1);
+
+    // Style node rectangles
+    nodeUpdate
+      .select('.node-rect')
+      .attr('width', ({ width }) => width)
+      .attr('height', ({ height }) => height)
+      .attr('x', ({ width }) => 0)
+      .attr('y', ({ height }) => 0)
+      .attr('cursor', 'pointer')
+      .attr('rx', 12)
+      .attr('fill', attrs.nodeDefaultBackground);
+
+    // Move node button group to the desired position
+    nodeUpdate
+      .select('.node-button-g')
+      .attr('transform', ({ data, width, height }) => {
+        const x = attrs.layoutBindings[attrs.layout].buttonX({ width, height });
+        const y = attrs.layoutBindings[attrs.layout].buttonY({ width, height });
+        return `translate(${x},${y})`;
+      })
+      .attr('display', ({ data }) => {
+        // return data._directSubordinates > 0 ? null : 'none';
+        return data.directReporteesCount > 0 ? null : 'none';
+      })
+      .attr('opacity', () => {return 1})
+      // .attr('opacity', ({ children, _children }) => {
+      //   if (children || _children) {
+      //     return 1;
+      //   }
+      //   return 0;
+      // });
+
+    // Restyle node button circle
+    nodeUpdate
+      .select('.node-button-foreign-object .node-button-div')
+      .html((node) => {
+        return attrs.buttonContent({ node, state: attrs });
+      });
+
+    // Restyle button texts
+    nodeUpdate
+      .select('.node-button-text')
+      .attr('text-anchor', 'middle')
+      .attr('alignment-baseline', 'middle')
+      .attr('fill', attrs.defaultTextFill)
+      .attr('font-size', ({ children }) => {
+        if (children) return 40;
+        return 26;
+      })
+      .text(({ children }) => {
+        if (children) return '-';
+        return '+';
+      })
+      .attr('y', this.isEdge() ? 10 : 0);
+
+    nodeUpdate.each(attrs.nodeUpdate);
+
+    // Remove any exiting nodes after transition
+    const nodeExitTransition = nodesSelection
+      .exit()
+      .attr('opacity', 1)
+      .transition()
+      .duration(attrs.duration)
+      .attr('transform', (d) => {
+        const ex = attrs.layoutBindings[attrs.layout].nodeJoinX({
+          x,
+          y,
+          width,
+          height,
+        });
+        const ey = attrs.layoutBindings[attrs.layout].nodeJoinY({
+          x,
+          y,
+          width,
+          height,
+        });
+        return `translate(${ex},${ey})`;
+      })
+      .on('end', function () {
+        d3.select(this).remove();
+      })
+      .attr('opacity', 0);
+
+    // Store the old positions for transition.
+    nodes.forEach((d) => {
+      d.x0 = d.x;
+      d.y0 = d.y;
+    });
+
+    // CHECK FOR CENTERING
+    const centeredNode = attrs.allNodes.filter((d) => d.data._centered)[0];
+    if (centeredNode) {
+      const centeredNodes = centeredNode.data._centeredWithDescendants
+        ? centeredNode.descendants().filter((d, i) => i < 7)
+        : [centeredNode];
+      centeredNode.data._centeredWithDescendants = null;
+      centeredNode.data._centered = null;
+      this.fit({
+        animate: true,
+        scale: false,
+        nodes: centeredNodes,
+      });
     }
+  }
 
-    // This function detects whether current browser is edge
-    isEdge() {
-        return window.navigator.userAgent.includes("Edge");
-    }
+  // This function detects whether current browser is edge
+  isEdge() {
+    return window.navigator.userAgent.includes('Edge');
+  }
 
-    // Generate horizontal diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges-horizontal-d3-v3-v4-v5-v6
-    hdiagonal(s, t, m) {
-        // Define source and target x,y coordinates
-        const x = s.x;
-        const y = s.y;
-        const ex = t.x;
-        const ey = t.y;
+  // Generate horizontal diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges-horizontal-d3-v3-v4-v5-v6
+  hdiagonal(s, t, m) {
+    // Define source and target x,y coordinates
+    const x = s.x;
+    const y = s.y;
+    const ex = t.x;
+    const ey = t.y;
 
-        let mx = m && m.x || x;
-        let my = m && m.y || y;
+    let mx = (m && m.x) || x;
+    let my = (m && m.y) || y;
 
-        // Values in case of top reversed and left reversed diagonals
-        let xrvs = ex - x < 0 ? -1 : 1;
-        let yrvs = ey - y < 0 ? -1 : 1;
+    // Values in case of top reversed and left reversed diagonals
+    let xrvs = ex - x < 0 ? -1 : 1;
+    let yrvs = ey - y < 0 ? -1 : 1;
 
-        // Define preferred curve radius
-        let rdef = 35;
+    // Define preferred curve radius
+    let rdef = 35;
 
-        // Reduce curve radius, if source-target x space is smaller
-        let r = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;
+    // Reduce curve radius, if source-target x space is smaller
+    let r = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;
 
-        // Further reduce curve radius, is y space is more small
-        r = Math.abs(ey - y) / 2 < r ? Math.abs(ey - y) / 2 : r;
+    // Further reduce curve radius, is y space is more small
+    r = Math.abs(ey - y) / 2 < r ? Math.abs(ey - y) / 2 : r;
 
-        // Defin width and height of link, excluding radius
-        let h = Math.abs(ey - y) / 2 - r;
-        let w = Math.abs(ex - x) / 2 - r;
+    // Defin width and height of link, excluding radius
+    let h = Math.abs(ey - y) / 2 - r;
+    let w = Math.abs(ex - x) / 2 - r;
 
-        // Build and return custom arc command
-        return `
+    // Build and return custom arc command
+    return `
                   M ${mx} ${my}
                   L ${mx} ${y}
                   L ${x} ${y}
@@ -1042,544 +1438,633 @@ export class OrgChart {
                     ${ex - w * xrvs}  ${ey}
                   L ${ex} ${ey}
        `;
-    }
+  }
 
-    // Generate custom diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges
-    diagonal(s, t, m) {
-        const x = s.x;
-        const y = s.y;
-        const ex = t.x;
-        const ey = t.y;
+  // Generate custom diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges
+  diagonal(s, t, m) {
+    const x = s.x;
+    const y = s.y;
+    const ex = t.x;
+    const ey = t.y;
 
-        let mx = m && m.x || x;
-        let my = m && m.y || y;
+    let mx = (m && m.x) || x;
+    let my = (m && m.y) || y;
 
-        let xrvs = ex - x < 0 ? -1 : 1;
-        let yrvs = ey - y < 0 ? -1 : 1;
+    let xrvs = ex - x < 0 ? -1 : 1;
+    let yrvs = ey - y < 0 ? -1 : 1;
 
-        let rdef = 35;
-        let r = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;
+    let rdef = 35;
+    let r = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;
 
-        r = Math.abs(ey - y) / 2 < r ? Math.abs(ey - y) / 2 : r;
+    r = Math.abs(ey - y) / 2 < r ? Math.abs(ey - y) / 2 : r;
 
-        let h = Math.abs(ey - y) / 2 - r;
-        let w = Math.abs(ex - x) - r * 2;
-        //w=0;
-        const path = `
+    let h = Math.abs(ey - y) / 2 - r;
+    let w = Math.abs(ex - x) - r * 2;
+    //w=0;
+    const path = `
                   M ${mx} ${my}
                   L ${x} ${my}
                   L ${x} ${y}
                   L ${x} ${y + h * yrvs}
-                  C  ${x} ${y + h * yrvs + r * yrvs} ${x} ${y + h * yrvs + r * yrvs
-            } ${x + r * xrvs} ${y + h * yrvs + r * yrvs}
+                  C  ${x} ${y + h * yrvs + r * yrvs} ${x} ${
+      y + h * yrvs + r * yrvs
+    } ${x + r * xrvs} ${y + h * yrvs + r * yrvs}
                   L ${x + w * xrvs + r * xrvs} ${y + h * yrvs + r * yrvs}
-                  C  ${ex}  ${y + h * yrvs + r * yrvs} ${ex}  ${y + h * yrvs + r * yrvs
-            } ${ex} ${ey - h * yrvs}
+                  C  ${ex}  ${y + h * yrvs + r * yrvs} ${ex}  ${
+      y + h * yrvs + r * yrvs
+    } ${ex} ${ey - h * yrvs}
                   L ${ex} ${ey}
        `;
-        return path;
+    return path;
+  }
+
+  restyleForeignObjectElements() {
+    const attrs = this.getChartState();
+
+    attrs.svg
+      .selectAll('.node-foreign-object')
+      .attr('width', ({ width }) => width)
+      .attr('height', ({ height }) => height)
+      .attr('x', ({ width }) => 0)
+      .attr('y', ({ height }) => 0);
+    attrs.svg
+      .selectAll('.node-foreign-object-div')
+      .style('width', ({ width }) => `${width}px`)
+      .style('height', ({ height }) => `${height}px`)
+      .html(function (d, i, arr) {
+        return attrs.nodeContent.bind(this)(d, i, arr, attrs);
+      });
+  }
+
+  // Toggle children on click.
+  onButtonClick(event, d) {
+    const attrs = this.getChartState();
+    if (attrs.setActiveNodeCentered) {
+      d.data._centered = true;
+      d.data._centeredWithDescendants = true;
     }
 
-    restyleForeignObjectElements() {
-        const attrs = this.getChartState();
-
-        attrs.svg
-            .selectAll(".node-foreign-object")
-            .attr("width", ({ width }) => width)
-            .attr("height", ({ height }) => height)
-            .attr("x", ({ width }) => 0)
-            .attr("y", ({ height }) => 0);
-        attrs.svg
-            .selectAll(".node-foreign-object-div")
-            .style("width", ({ width }) => `${width}px`)
-            .style("height", ({ height }) => `${height}px`)
-            .html(function (d, i, arr) { return attrs.nodeContent.bind(this)(d, i, arr, attrs) })
+    // If childrens are expanded
+    if (d.children) {
+      //Collapse them
+      d._children = d.children;
+      d.children = null;
+
+      // Set descendants expanded property to false
+      this.setExpansionFlagToChildren(d, false);
+    } else {
+      // Expand children
+      d.children = d._children;
+      d._children = null;
+
+      // Set each children as expanded
+      if (d.children) {
+        d.children.forEach(({ data }) => (data._expanded = true));
+      }
     }
 
-    // Toggle children on click.
-    onButtonClick(event, d) {
-        const attrs = this.getChartState();
-        if (attrs.setActiveNodeCentered) {
-            d.data._centered = true;
-            d.data._centeredWithDescendants = true;
-        }
-
-        // If childrens are expanded
-        if (d.children) {
-            //Collapse them
-            d._children = d.children;
-            d.children = null;
+    // Redraw Graph
+    this.update(d);
 
-            // Set descendants expanded property to false
-            this.setExpansionFlagToChildren(d, false);
-        } else {
-            // Expand children
-            d.children = d._children;
-            d._children = null;
+    attrs.onExpandCollapseClick(d, attrs.data);
+  }
 
-            // Set each children as expanded
-            if (d.children) {
-                d.children.forEach(({ data }) => (data._expanded = true));
-            }
-        }
+  // This function changes `expanded` property to descendants
+  setExpansionFlagToChildren({ data, children, _children }, flag) {
+    // Set flag to the current property
+    data._expanded = flag;
 
-        // Redraw Graph
-        this.update(d);
+    // Loop over and recursively update expanded children's descendants
+    if (children) {
+      children.forEach((d) => {
+        this.setExpansionFlagToChildren(d, flag);
+      });
     }
 
-    // This function changes `expanded` property to descendants
-    setExpansionFlagToChildren({ data, children, _children }, flag) {
-        // Set flag to the current property
-        data._expanded = flag;
-
-        // Loop over and recursively update expanded children's descendants
-        if (children) {
-            children.forEach((d) => {
-                this.setExpansionFlagToChildren(d, flag);
-            });
-        }
-
-        // Loop over and recursively update collapsed children's descendants
-        if (_children) {
-            _children.forEach((d) => {
-                this.setExpansionFlagToChildren(d, flag);
-            });
-        }
+    // Loop over and recursively update collapsed children's descendants
+    if (_children) {
+      _children.forEach((d) => {
+        this.setExpansionFlagToChildren(d, flag);
+      });
     }
-
-
-    // Method which only expands nodes, which have property set "expanded=true"
-    expandSomeNodes(d) {
-        // If node has expanded property set
-        if (d.data._expanded) {
-            // Retrieve node's parent
-            let parent = d.parent;
-
-            // While we can go up
-            while (parent) {
-                // Expand all current parent's children
-                if (parent._children) {
-                    parent.children = parent._children;
-                }
-
-                // Replace current parent holding object
-                parent = parent.parent;
-            }
+  }
+
+  // Method which only expands nodes, which have property set "expanded=true"
+  expandSomeNodes(d) {
+    // If node has expanded property set
+    if (d.data._expanded) {
+      // Retrieve node's parent
+      let parent = d.parent;
+
+      // While we can go up
+      while (parent) {
+        // Expand all current parent's children
+        if (parent._children) {
+          parent.children = parent._children;
         }
 
-        // Recursivelly do the same for collapsed nodes
-        if (d._children) {
-            d._children.forEach((ch) => this.expandSomeNodes(ch));
-        }
-
-        // Recursivelly do the same for expanded nodes
-        if (d.children) {
-            d.children.forEach((ch) => this.expandSomeNodes(ch));
-        }
+        // Replace current parent holding object
+        parent = parent.parent;
+      }
     }
 
-    // This function updates nodes state and redraws graph, usually after data change
-    updateNodesState() {
-        const attrs = this.getChartState();
-
-        this.setLayouts({ expandNodesFirst: true });
-
-        // Redraw Graphs
-        this.update(attrs.root);
+    // Recursivelly do the same for collapsed nodes
+    if (d._children) {
+      d._children.forEach((ch) => this.expandSomeNodes(ch));
     }
 
-    setLayouts({ expandNodesFirst = true }) {
-        const attrs = this.getChartState();
-        // Store new root by converting flat data to hierarchy
-        attrs.root = d3
-            .stratify()
-            .id((d) => attrs.nodeId(d))
-            .parentId(d => attrs.parentNodeId(d))(attrs.data);
-
-        attrs.root.each((node, i, arr) => {
-            let width = attrs.nodeWidth(node);
-            let height = attrs.nodeHeight(node);
-            Object.assign(node, { width, height })
-        })
-
-        // Store positions, where children appear during their enter animation
-        attrs.root.x0 = 0;
-        attrs.root.y0 = 0;
-        attrs.allNodes = attrs.root.descendants();
-
-        // Store direct and total descendants count
-        attrs.allNodes.forEach((d) => {
-            Object.assign(d.data, {
-                _directSubordinates: d.children ? d.children.length : 0,
-                _totalSubordinates: d.descendants().length - 1
-            });
-        });
-
-        if (attrs.root.children) {
-            if (expandNodesFirst) {
-                // Expand all nodes first
-                attrs.root.children.forEach(this.expand);
-            }
-            // Then collapse them all
-            attrs.root.children.forEach((d) => this.collapse(d));
-
-            // Collapse root if level is 0
-            if (attrs.expandLevel == 0) {
-                attrs.root._children = attrs.root.children;
-                attrs.root.children = null;
-            }
-
-            // Then only expand nodes, which have expanded proprty set to true
-            [attrs.root].forEach((ch) => this.expandSomeNodes(ch));
-        }
-    }
-
-    // Function which collapses passed node and it's descendants
-    collapse(d) {
-        if (d.children) {
-            d._children = d.children;
-            d._children.forEach((ch) => this.collapse(ch));
-            d.children = null;
-        }
-    }
-
-    // Function which expands passed node and it's descendants
-    expand(d) {
-        if (d._children) {
-            d.children = d._children;
-            d.children.forEach((ch) => this.expand(ch));
-            d._children = null;
-        }
+    // Recursivelly do the same for expanded nodes
+    if (d.children) {
+      d.children.forEach((ch) => this.expandSomeNodes(ch));
     }
-
-    // Zoom handler function
-    zoomed(event, d) {
-        const attrs = this.getChartState();
-        const chart = attrs.chart;
-
-        // Get d3 event's transform object
-        const transform = event.transform;
-
-        // Store it
-        attrs.lastTransform = transform;
-
-        // Reposition and rescale chart accordingly
-        chart.attr("transform", transform);
-
-        // Apply new styles to the foreign object element
-        if (this.isEdge()) {
-            this.restyleForeignObjectElements();
-        }
+  }
+
+  // This function updates nodes state and redraws graph, usually after data change
+  updateNodesState() {
+    const attrs = this.getChartState();
+
+    this.setLayouts({ expandNodesFirst: true });
+
+    // Redraw Graphs
+    this.update(attrs.root);
+  }
+
+  setLayouts({ expandNodesFirst = true }) {
+    const attrs = this.getChartState();
+    // Store new root by converting flat data to hierarchy
+    attrs.root = d3
+      .stratify()
+      .id((d) => attrs.nodeId(d))
+      .parentId((d) => attrs.parentNodeId(d))(attrs.data);
+
+    attrs.root.each((node, i, arr) => {
+      let width = attrs.nodeWidth(node);
+      let height = attrs.nodeHeight(node);
+      Object.assign(node, { width, height });
+    });
+
+    // Store positions, where children appear during their enter animation
+    attrs.root.x0 = 0;
+    attrs.root.y0 = 0;
+    attrs.allNodes = attrs.root.descendants();
+
+    // Store direct and total descendants count
+    attrs.allNodes.forEach((d) => {
+      Object.assign(d.data, {
+        _directSubordinates: d.children ? d.children.length : 0,
+        _totalSubordinates: d.descendants().length - 1,
+      });
+    });
+
+    if (attrs.root.children) {
+      if (expandNodesFirst) {
+        // Expand all nodes first
+        attrs.root.children.forEach(this.expand);
+      }
+      // Then collapse them all
+      attrs.root.children.forEach((d) => this.collapse(d));
+
+      // Collapse root if level is 0
+      if (attrs.expandLevel == 0) {
+        attrs.root._children = attrs.root.children;
+        attrs.root.children = null;
+      }
+
+      // Then only expand nodes, which have expanded proprty set to true
+      [attrs.root].forEach((ch) => this.expandSomeNodes(ch));
     }
-
-    zoomTreeBounds({ x0, x1, y0, y1, params = { animate: true, scale: true } }) {
-        const { centerG, svgWidth: w, svgHeight: h, svg, zoomBehavior, duration, lastTransform } = this.getChartState()
-        let scaleVal = Math.min(8, 0.9 / Math.max((x1 - x0) / w, (y1 - y0) / h));
-        let identity = d3.zoomIdentity.translate(w / 2, h / 2)
-        identity = identity.scale(params.scale ? scaleVal : lastTransform.k)
-
-        identity = identity.translate(-(x0 + x1) / 2, -(y0 + y1) / 2);
-        // Transition zoom wrapper component into specified bounds
-        svg.transition().duration(params.animate ? duration : 0).call(zoomBehavior.transform, identity);
-        centerG.transition().duration(params.animate ? duration : 0).attr('transform', 'translate(0,0)')
+  }
+
+  // Function which collapses passed node and it's descendants
+  collapse(d) {
+    if (d.children) {
+      d._children = d.children;
+      d._children.forEach((ch) => this.collapse(ch));
+      d.children = null;
     }
-
-    fit({ animate = true, nodes, scale = true } = {}) {
-        const attrs = this.getChartState();
-        const { root } = attrs;
-        let descendants = nodes ? nodes : root.descendants();
-        const minX = d3.min(descendants, d => d.x + attrs.layoutBindings[attrs.layout].nodeLeftX(d))
-        const maxX = d3.max(descendants, d => d.x + attrs.layoutBindings[attrs.layout].nodeRightX(d))
-        const minY = d3.min(descendants, d => d.y + attrs.layoutBindings[attrs.layout].nodeTopY(d))
-        const maxY = d3.max(descendants, d => d.y + attrs.layoutBindings[attrs.layout].nodeBottomY(d))
-
-        this.zoomTreeBounds({
-            params: { animate: animate, scale },
-            x0: minX - 50,
-            x1: maxX + 50,
-            y0: minY - 50,
-            y1: maxY + 50,
-        });
-        return this;
+  }
+
+  // Function which expands passed node and it's descendants
+  expand(d) {
+    if (d._children) {
+      d.children = d._children;
+      d.children.forEach((ch) => this.expand(ch));
+      d._children = null;
     }
+  }
 
-    // This function can be invoked via chart.setExpanded API, it expands or collapses particular node
-    setExpanded(id, expandedFlag = true) {
+  // Zoom handler function
+  zoomed(event, d) {
+    const attrs = this.getChartState();
+    const chart = attrs.chart;
 
-        const attrs = this.getChartState();
-        // Retrieve node by node Id
-        const node = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) == id)[0];
+    // Get d3 event's transform object
+    const transform = event.transform;
 
-        if (!node) {
-            console.log(`ORG CHART - ${expandedFlag ? "EXPAND" : "COLLAPSE"} - Node with id (${id})  not found in the tree`)
-            return this;
-        }
-        node.data._expanded = expandedFlag;
-        return this;
-    }
+    // Store it
+    attrs.lastTransform = transform;
 
-    setCentered(nodeId) {
-        const attrs = this.getChartState();
-        // this.setExpanded(nodeId)
-        const node = attrs.allNodes.filter(d => attrs.nodeId(d.data) === nodeId)[0];
-        if (!node) {
-            console.log(`ORG CHART - CENTER - Node with id (${nodeId}) not found in the tree`)
-            return this;
-        }
-        node.data._centered = true;
-        node.data._expanded = true;
-        return this;
-    }
+    // Reposition and rescale chart accordingly
+    chart.attr('transform', transform);
 
-    setHighlighted(nodeId) {
-        const attrs = this.getChartState();
-        const node = attrs.allNodes.filter(d => attrs.nodeId(d.data) === nodeId)[0];
-        if (!node) {
-            console.log(`ORG CHART - HIGHLIGHT - Node with id (${nodeId})  not found in the tree`);
-            return this
-        }
-        node.data._highlighted = true;
-        node.data._expanded = true;
-        node.data._centered = true;
-        return this;
-    }
-
-    setUpToTheRootHighlighted(nodeId) {
-        const attrs = this.getChartState();
-        const node = attrs.allNodes.filter(d => attrs.nodeId(d.data) === nodeId)[0];
-        if (!node) {
-            console.log(`ORG CHART - HIGHLIGHTROOT - Node with id (${nodeId}) not found in the tree`)
-            return this;
-        }
-        node.data._upToTheRootHighlighted = true;
-        node.data._expanded = true;
-        node.ancestors().forEach(d => d.data._upToTheRootHighlighted = true)
-        return this;
+    // Apply new styles to the foreign object element
+    if (this.isEdge()) {
+      this.restyleForeignObjectElements();
     }
-
-    clearHighlighting() {
-        const attrs = this.getChartState();
-        attrs.allNodes.forEach(d => {
-            d.data._highlighted = false;
-            d.data._upToTheRootHighlighted = false;
-        })
-        this.update(attrs.root)
+  }
+
+  zoomTreeBounds({ x0, x1, y0, y1, params = { animate: true, scale: true } }) {
+    const {
+      centerG,
+      svgWidth: w,
+      svgHeight: h,
+      svg,
+      zoomBehavior,
+      duration,
+      lastTransform,
+    } = this.getChartState();
+    let scaleVal = Math.min(8, 0.9 / Math.max((x1 - x0) / w, (y1 - y0) / h));
+    let identity = d3.zoomIdentity.translate(w / 2, h / 2);
+    identity = identity.scale(params.scale ? scaleVal : lastTransform.k);
+
+    identity = identity.translate(-(x0 + x1) / 2, -(y0 + y1) / 2);
+    // Transition zoom wrapper component into specified bounds
+    svg
+      .transition()
+      .duration(params.animate ? duration : 0)
+      .call(zoomBehavior.transform, identity);
+    centerG
+      .transition()
+      .duration(params.animate ? duration : 0)
+      .attr('transform', 'translate(0,0)');
+  }
+
+  fit({ animate = true, nodes, scale = true } = {}) {
+    const attrs = this.getChartState();
+    const { root } = attrs;
+    let descendants = nodes ? nodes : root.descendants();
+    const minX = d3.min(
+      descendants,
+      (d) => d.x + attrs.layoutBindings[attrs.layout].nodeLeftX(d),
+    );
+    const maxX = d3.max(
+      descendants,
+      (d) => d.x + attrs.layoutBindings[attrs.layout].nodeRightX(d),
+    );
+    const minY = d3.min(
+      descendants,
+      (d) => d.y + attrs.layoutBindings[attrs.layout].nodeTopY(d),
+    );
+    const maxY = d3.max(
+      descendants,
+      (d) => d.y + attrs.layoutBindings[attrs.layout].nodeBottomY(d),
+    );
+
+    this.zoomTreeBounds({
+      params: { animate: animate, scale },
+      x0: minX - 50,
+      x1: maxX + 50,
+      y0: minY - 50,
+      y1: maxY + 50,
+    });
+    return this;
+  }
+
+  // This function can be invoked via chart.setExpanded API, it expands or collapses particular node
+  setExpanded(id, expandedFlag = true) {
+    const attrs = this.getChartState();
+    // Retrieve node by node Id
+    const node = attrs.allNodes.filter(
+      ({ data }) => attrs.nodeId(data) == id,
+    )[0];
+
+    if (!node) {
+      console.log(
+        `ORG CHART - ${
+          expandedFlag ? 'EXPAND' : 'COLLAPSE'
+        } - Node with id (${id})  not found in the tree`,
+      );
+      return this;
     }
-
-    // It can take selector which would go fullscreen
-    fullscreen(elem) {
-        const attrs = this.getChartState();
-        const el = d3.select(elem || attrs.container).node();
-
-        d3.select(document).on('fullscreenchange.' + attrs.id, function (d) {
-            const fsElement = document.fullscreenElement || document.mozFullscreenElement || document.webkitFullscreenElement;
-            if (fsElement == el) {
-                setTimeout(d => {
-                    attrs.svg.attr('height', window.innerHeight - 40);
-                }, 500)
-            } else {
-                attrs.svg.attr('height', attrs.svgHeight)
-            }
-        })
-
-        if (el.requestFullscreen) {
-            el.requestFullscreen();
-        } else if (el.mozRequestFullScreen) {
-            el.mozRequestFullScreen();
-        } else if (el.webkitRequestFullscreen) {
-            el.webkitRequestFullscreen();
-        } else if (el.msRequestFullscreen) {
-            el.msRequestFullscreen();
-        }
+    node.data._expanded = expandedFlag;
+    return this;
+  }
+
+  setCentered(nodeId) {
+    const attrs = this.getChartState();
+    // this.setExpanded(nodeId)
+    const node = attrs.allNodes.filter(
+      (d) => attrs.nodeId(d.data) === nodeId,
+    )[0];
+    if (!node) {
+      console.log(
+        `ORG CHART - CENTER - Node with id (${nodeId}) not found in the tree`,
+      );
+      return this;
     }
-
-    // Zoom in exposed method
-    zoomIn() {
-        const { svg, zoomBehavior } = this.getChartState();
-        svg.transition().call(zoomBehavior.scaleBy, 1.3);
+    node.data._centered = true;
+    node.data._expanded = true;
+    return this;
+  }
+
+  setHighlighted(nodeId) {
+    const attrs = this.getChartState();
+    const node = attrs.allNodes.filter(
+      (d) => attrs.nodeId(d.data) === nodeId,
+    )[0];
+    if (!node) {
+      console.log(
+        `ORG CHART - HIGHLIGHT - Node with id (${nodeId})  not found in the tree`,
+      );
+      return this;
     }
-
-    // Zoom out exposed method
-    zoomOut() {
-        const { svg, zoomBehavior } = this.getChartState();
-        svg.transition().call(zoomBehavior.scaleBy, 0.78);
+    node.data._highlighted = true;
+    node.data._expanded = true;
+    node.data._centered = true;
+    return this;
+  }
+
+  setUpToTheRootHighlighted(nodeId) {
+    const attrs = this.getChartState();
+    const node = attrs.allNodes.filter(
+      (d) => attrs.nodeId(d.data) === nodeId,
+    )[0];
+    if (!node) {
+      console.log(
+        `ORG CHART - HIGHLIGHTROOT - Node with id (${nodeId}) not found in the tree`,
+      );
+      return this;
     }
-
-    toDataURL(url, callback) {
-        var xhr = new XMLHttpRequest();
-        xhr.onload = function () {
-            var reader = new FileReader();
-            reader.onloadend = function () {
-                callback(reader.result);
-            }
-            reader.readAsDataURL(xhr.response);
-        };
-        xhr.open('GET', url);
-        xhr.responseType = 'blob';
-        xhr.send();
+    node.data._upToTheRootHighlighted = true;
+    node.data._upToTheRootHighlightedNode = true;
+    node.data._expanded = true;
+    node.ancestors().forEach((d) => (d.data._upToTheRootHighlighted = true));
+    return this;
+  }
+
+  clearHighlighting() {
+    const attrs = this.getChartState();
+    attrs.allNodes.forEach((d) => {
+      d.data._highlighted = false;
+      d.data._upToTheRootHighlighted = false;
+      d.data._upToTheRootHighlightedNode = false;
+    });
+    this.update(attrs.root);
+  }
+
+  // It can take selector which would go fullscreen
+  fullscreen(elem) {
+    const attrs = this.getChartState();
+    const el = d3.select(elem || attrs.container).node();
+
+    d3.select(document).on('fullscreenchange.' + attrs.id, function (d) {
+      const fsElement =
+        document.fullscreenElement ||
+        document.mozFullscreenElement ||
+        document.webkitFullscreenElement;
+      if (fsElement == el) {
+        setTimeout((d) => {
+          attrs.svg.attr('height', window.innerHeight - 40);
+        }, 500);
+      } else {
+        attrs.svg.attr('height', attrs.svgHeight);
+      }
+    });
+
+    if (el.requestFullscreen) {
+      el.requestFullscreen();
+    } else if (el.mozRequestFullScreen) {
+      el.mozRequestFullScreen();
+    } else if (el.webkitRequestFullscreen) {
+      el.webkitRequestFullscreen();
+    } else if (el.msRequestFullscreen) {
+      el.msRequestFullscreen();
     }
-
-    exportImg({ full = false, scale = 3, onLoad = d => d, save = true } = {}) {
-        const that = this;
-        const attrs = this.getChartState();
-        const { svg: svgImg, root } = attrs
-        let count = 0;
-        const selection = svgImg.selectAll('img')
-        let total = selection.size()
-
-        const exportImage = () => {
-            const transform = JSON.parse(JSON.stringify(that.lastTransform()));
-            const duration = that.duration();
-            if (full) {
-                that.fit();
-            }
-            const { svg } = that.getChartState()
-
-            setTimeout(d => {
-                that.downloadImage({
-                    node: svg.node(), scale, isSvg: false,
-                    onAlreadySerialized: d => {
-                        that.update(root)
-                    },
-                    onLoad: onLoad,
-                    save
-                })
-            }, full ? duration + 10 : 0)
-        }
-
-        if (total > 0) {
-            selection
-                .each(function () {
-                    that.toDataURL(this.src, (dataUrl) => {
-                        this.src = dataUrl;
-                        if (++count == total) {
-                            exportImage();
-                        }
-                    })
-                })
-        } else {
+  }
+
+  // Zoom in exposed method
+  zoomIn() {
+    const { svg, zoomBehavior } = this.getChartState();
+    svg.transition().call(zoomBehavior.scaleBy, 1.1);
+  }
+
+  // Zoom out exposed method
+  zoomOut() {
+    const { svg, zoomBehavior } = this.getChartState();
+    svg.transition().call(zoomBehavior.scaleBy, 0.9);
+  }
+
+  // set zoom
+  setZoom(zoomScale) {
+    const { svg, zoomBehavior } = this.getChartState();
+    svg.transition().call(zoomBehavior.scaleTo, zoomScale);
+    return this;
+  }
+
+  toDataURL(url, callback) {
+    var xhr = new XMLHttpRequest();
+    xhr.onload = function () {
+      var reader = new FileReader();
+      reader.onloadend = function () {
+        callback(reader.result);
+      };
+      reader.readAsDataURL(xhr.response);
+    };
+    xhr.open('GET', url);
+    xhr.responseType = 'blob';
+    xhr.send();
+  }
+
+  exportImg({ full = false, scale = 3, onLoad = (d) => d, save = true } = {}) {
+    const that = this;
+    const attrs = this.getChartState();
+    const { svg: svgImg, root } = attrs;
+    let count = 0;
+    const selection = svgImg.selectAll('img');
+    let total = selection.size();
+
+    const exportImage = () => {
+      const transform = JSON.parse(JSON.stringify(that.lastTransform()));
+      const duration = that.duration();
+      if (full) {
+        that.fit();
+      }
+      const { svg } = that.getChartState();
+
+      setTimeout(
+        (d) => {
+          that.downloadImage({
+            node: svg.node(),
+            scale,
+            isSvg: false,
+            onAlreadySerialized: (d) => {
+              that.update(root);
+            },
+            onLoad: onLoad,
+            save,
+          });
+        },
+        full ? duration + 10 : 0,
+      );
+    };
+
+    if (total > 0) {
+      selection.each(function () {
+        that.toDataURL(this.src, (dataUrl) => {
+          this.src = dataUrl;
+          if (++count == total) {
             exportImage();
-        }
-
-
+          }
+        });
+      });
+    } else {
+      exportImage();
     }
-
-
-
-    exportSvg() {
-        const { svg } = this.getChartState();
-        this.downloadImage({ node: svg.node(), scale: 3, isSvg: true })
-        return this;
+  }
+
+  exportSvg() {
+    const { svg } = this.getChartState();
+    this.downloadImage({ node: svg.node(), scale: 3, isSvg: true });
+    return this;
+  }
+
+  expandAll() {
+    const { allNodes, root } = this.getChartState();
+    allNodes.forEach((d) => (d.data._expanded = true));
+    this.render();
+    return this;
+  }
+
+  collapseAll() {
+    const { allNodes, root } = this.getChartState();
+    allNodes.forEach((d) => (d.data._expanded = false));
+    this.expandLevel(0);
+    this.render();
+    return this;
+  }
+
+  downloadImage({
+    node,
+    scale = 2,
+    isSvg = false,
+    save = true,
+    onAlreadySerialized = (d) => {},
+    onLoad = (d) => {},
+  }) {
+    // Retrieve svg node
+    const svgNode = node;
+
+    if (isSvg) {
+      let source = serializeString(svgNode);
+      //add xml declaration
+      source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
+      //convert svg source to URI data scheme.
+      var url =
+        'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(source);
+      saveAs(url, 'graph.svg');
+      onAlreadySerialized();
+      return;
     }
-
-    expandAll() {
-        const { allNodes, root } = this.getChartState();
-        allNodes.forEach(d => d.data._expanded = true);
-        this.render()
-        return this;
+    // Get image quality index (basically,  index you can zoom in)
+    const quality = scale;
+    // Create image
+    const image = document.createElement('img');
+    image.onload = function () {
+      // Create image canvas
+      const canvas = document.createElement('canvas');
+      // Set width and height based on SVG node
+      const rect = svgNode.getBoundingClientRect();
+      canvas.width = rect.width * quality;
+      canvas.height = rect.height * quality;
+      // Draw background
+      const context = canvas.getContext('2d');
+      context.fillStyle = '#FAFAFA';
+      context.fillRect(0, 0, rect.width * quality, rect.height * quality);
+      context.drawImage(
+        image,
+        0,
+        0,
+        rect.width * quality,
+        rect.height * quality,
+      );
+      // Set some image metadata
+      let dt = canvas.toDataURL('image/png');
+      if (onLoad) {
+        onLoad(dt);
+      }
+      if (save) {
+        // Invoke saving function
+        saveAs(dt, 'graph.png');
+      }
+    };
+
+    var url =
+      'data:image/svg+xml; charset=utf8, ' +
+      encodeURIComponent(serializeString(svgNode));
+
+    onAlreadySerialized();
+
+    image.src = url; // URL.createObjectURL(blob);
+    // This function invokes save window
+    function saveAs(uri, filename) {
+      // create link
+      var link = document.createElement('a');
+      if (typeof link.download === 'string') {
+        document.body.appendChild(link); // Firefox requires the link to be in the body
+        link.download = filename;
+        link.href = uri;
+        link.click();
+        document.body.removeChild(link); // remove the link when done
+      } else {
+        location.replace(uri);
+      }
     }
-
-    collapseAll() {
-        const { allNodes, root } = this.getChartState();
-        allNodes.forEach(d => d.data._expanded = false);
-        this.expandLevel(0)
-        this.render();
-        return this;
-    }
-
-    downloadImage({ node, scale = 2, isSvg = false, save = true, onAlreadySerialized = d => { }, onLoad = d => { } }) {
-        // Retrieve svg node
-        const svgNode = node;
-
-        if (isSvg) {
-            let source = serializeString(svgNode);
-            //add xml declaration
-            source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
-            //convert svg source to URI data scheme.
-            var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
-            saveAs(url, "graph.svg");
-            onAlreadySerialized()
-            return;
-        }
-        // Get image quality index (basically,  index you can zoom in)
-        const quality = scale
-        // Create image
-        const image = document.createElement('img');
-        image.onload = function () {
-            // Create image canvas
-            const canvas = document.createElement('canvas');
-            // Set width and height based on SVG node
-            const rect = svgNode.getBoundingClientRect();
-            canvas.width = rect.width * quality;
-            canvas.height = rect.height * quality;
-            // Draw background
-            const context = canvas.getContext('2d');
-            context.fillStyle = '#FAFAFA';
-            context.fillRect(0, 0, rect.width * quality, rect.height * quality);
-            context.drawImage(image, 0, 0, rect.width * quality, rect.height * quality);
-            // Set some image metadata
-            let dt = canvas.toDataURL('image/png');
-            if (onLoad) {
-                onLoad(dt)
-            }
-            if (save) {
-                // Invoke saving function
-                saveAs(dt, 'graph.png');
-            }
-
-        };
-
-        var url = 'data:image/svg+xml; charset=utf8, ' + encodeURIComponent(serializeString(svgNode));
-
-        onAlreadySerialized()
-
-        image.src = url// URL.createObjectURL(blob);
-        // This function invokes save window
-        function saveAs(uri, filename) {
-            // create link
-            var link = document.createElement('a');
-            if (typeof link.download === 'string') {
-                document.body.appendChild(link); // Firefox requires the link to be in the body
-                link.download = filename;
-                link.href = uri;
-                link.click();
-                document.body.removeChild(link); // remove the link when done
-            } else {
-                location.replace(uri);
-            }
+    // This function serializes SVG and sets all necessary attributes
+    function serializeString(svg) {
+      const xmlns = 'http://www.w3.org/2000/xmlns/';
+      const xlinkns = 'http://www.w3.org/1999/xlink';
+      const svgns = 'http://www.w3.org/2000/svg';
+      svg = svg.cloneNode(true);
+      const fragment = window.location.href + '#';
+      const walker = document.createTreeWalker(
+        svg,
+        NodeFilter.SHOW_ELEMENT,
+        null,
+        false,
+      );
+      while (walker.nextNode()) {
+        for (const attr of walker.currentNode.attributes) {
+          if (attr.value.includes(fragment)) {
+            attr.value = attr.value.replace(fragment, '#');
+          }
         }
-        // This function serializes SVG and sets all necessary attributes
-        function serializeString(svg) {
-            const xmlns = 'http://www.w3.org/2000/xmlns/';
-            const xlinkns = 'http://www.w3.org/1999/xlink';
-            const svgns = 'http://www.w3.org/2000/svg';
-            svg = svg.cloneNode(true);
-            const fragment = window.location.href + '#';
-            const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT, null, false);
-            while (walker.nextNode()) {
-                for (const attr of walker.currentNode.attributes) {
-                    if (attr.value.includes(fragment)) {
-                        attr.value = attr.value.replace(fragment, '#');
-                    }
-                }
-            }
-            svg.setAttributeNS(xmlns, 'xmlns', svgns);
-            svg.setAttributeNS(xmlns, 'xmlns:xlink', xlinkns);
-            const serializer = new XMLSerializer();
-            const string = serializer.serializeToString(svg);
-            return string;
-        }
-    }
-
-    // Calculate what size text will take
-    getTextWidth(text, {
-        fontSize = 14,
-        fontWeight = 400,
-        defaultFont = "Helvetice",
-        ctx
-    } = {}) {
-        ctx.font = `${fontWeight || ''} ${fontSize}px ${defaultFont} `
-        const measurement = ctx.measureText(text);
-        return measurement.width;
+      }
+      svg.setAttributeNS(xmlns, 'xmlns', svgns);
+      svg.setAttributeNS(xmlns, 'xmlns:xlink', xlinkns);
+      const serializer = new XMLSerializer();
+      const string = serializer.serializeToString(svg);
+      return string;
     }
+  }
+
+  // Calculate what size text will take
+  getTextWidth(
+    text,
+    { fontSize = 14, fontWeight = 400, defaultFont = 'Helvetice', ctx } = {},
+  ) {
+    ctx.font = `${fontWeight || ''} ${fontSize}px ${defaultFont} `;
+    const measurement = ctx.measureText(text);
+    return measurement.width;
+  }
+
+  getNodeData(nodeId) {
+    const attrs = this.getChartState();
+    return attrs.allNodes.find((node) => node.id === nodeId);
+  }
+  getCountNodeId(parentNodeId) {
+    const attrs = this.getChartState();
+    const parentNode = attrs.allNodes.find((node) => node.id === parentNodeId);
+    return parentNode.children
+      .map((node) => node.id)[0];
+  }
 }
